'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var util = require('@ethereumjs/util');
var baseControllers = require('@toruslabs/base-controllers');
var BN = require('bn.js');
var log = require('loglevel');
var eip7702Types = require('../utils/eip7702Types.js');
var TransactionUtils = require('./TransactionUtils.js');

class TransactionGasUtil {
  constructor(provider, blockTracker) {
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.blockTracker.getLatestBlock();
    // fallback to block gasLimit
    const blockGasLimitBN = new BN.BN(util.stripHexPrefix(block.gasLimit), 16);
    const saferGasLimitBN = blockGasLimitBN.mul(new BN.BN(19)).div(new BN.BN(20));
    let estimatedGasHex = util.addHexPrefix(saferGasLimitBN.toString("hex"));
    let simulationFails;
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      log.warn(error);
      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.idempotencyKey,
          blockGasLimit: block.gasLimit
        }
      };
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }
  /**
    Adds a gas buffer with out exceeding the block gas limit
  */
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = new BN.BN(util.stripHexPrefix(initialGasLimitHex), 16);
    const blockGasLimitBn = new BN.BN(util.stripHexPrefix(blockGasLimitHex), 16);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);
    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return util.addHexPrefix(initialGasLimitBn.toString("hex"));
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return util.addHexPrefix(bufferedGasLimitBn.toString("hex"));
    // otherwise use blockGasLimit
    return util.addHexPrefix(upperGasLimitBn.toString("hex"));
  }
  /**
    Estimates the tx's gas usage
  */
  async estimateTxGas(txMeta) {
    const txParams = baseControllers.cloneDeep(txMeta.transaction);
    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    const eip7702SetCodeTx = TransactionUtils.isEip7702SetCodeTx(txMeta);
    if (eip7702SetCodeTx) {
      // assign dummy signature for the gas estimation
      txParams.authorizationList = txParams.authorizationList.map(authorization => _objectSpread(_objectSpread({}, authorization), {}, {
        nonce: authorization.nonce || "0x1",
        r: eip7702Types.DUMMY_AUTHORIZATION_SIGNATURE,
        s: eip7702Types.DUMMY_AUTHORIZATION_SIGNATURE,
        yParity: "0x1"
      }));
    }
    return this.provider.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
  }
}

exports.TransactionGasUtil = TransactionGasUtil;
