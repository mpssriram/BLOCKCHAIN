import { TransactionStatus } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@web3auth/auth";
import { NestedTransactionMetadata, TransactionBatchSingleRequest } from "../utils/eip5792Types";
import { EthereumTransactionMeta, TransactionParams } from "../utils/interfaces";
type NormalizableTransactionParams = keyof Omit<TransactionParams, "accessList">;
/**
 * normalizes txParams
 */
export declare function normalizeTxParameters(txParameters: TransactionParams, lowerCase?: boolean): TransactionParams;
export declare function transactionMatchesNetwork(transaction: EthereumTransactionMeta, chainId: string): boolean;
/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *  the transaction to check
 * @returns true if transaction uses valid EIP1559 fields
 */
export declare function isEIP1559Transaction(transaction: Partial<EthereumTransactionMeta>): boolean;
/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 * transaction -
 *  the transaction to check
 * @returns true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
export declare function isLegacyTransaction(transaction: EthereumTransactionMeta): boolean;
/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 */
export declare function ensureMutuallyExclusiveFieldsNotProvided(txParams: TransactionParams, fieldBeingValidated: NormalizableTransactionParams, mutuallyExclusiveField: NormalizableTransactionParams): void;
/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 */
export declare function ensureFieldIsString(txParams: TransactionParams, field: NormalizableTransactionParams): void;
/**
 * validates the from field in  txParams
 */
export declare function validateFrom(txParams: TransactionParams): void;
/**
 * validates the to field in  txParams
 */
export declare function validateRecipient(txParameters: TransactionParams): TransactionParams;
/**
 * Validates the given tx parameters
 * @throws if the tx params contains invalid fields
 */
export declare function validateTxParameters(txParams: TransactionParams, eip1559Compatibility?: boolean): void;
export declare function normalizeAndValidateTxParams(txParams: TransactionParams, lowerCase?: boolean): TransactionParams;
/**
 * @returns an array of states that can be considered final
 */
export declare function getFinalStates(): TransactionStatus[];
export declare function parseStandardTokenTransactionData(data: string): {
    name: string;
    methodParams: any[];
    type: string;
};
export declare const readAddressAsContract: (provider: SafeEventEmitterProvider, address: string) => Promise<{
    contractCode: string;
    isContractAddress: boolean;
}>;
export declare function determineTransactionType(txParams: TransactionParams, provider: SafeEventEmitterProvider, overrideTxMeta?: Partial<EthereumTransactionMeta>): Promise<{
    type: string;
    category: string;
    methodParams: any[];
    getCodeResponse: string;
}>;
/**
 * Create the nested transaction metadata for a batch transaction.
 *
 * Reference: {@link https://github.com/MetaMask/core/blob/main/packages/transaction-controller/src/utils/batch.ts#L253}
 *
 * @param from - The sender address.
 * @param batchTxParam - The batch transaction parameter.
 * @param provider - The provider.
 * @returns The nested transaction metadata.
 */
export declare function createNestedTransactionMeta(from: `0x${string}`, batchTxParam: TransactionBatchSingleRequest, provider: SafeEventEmitterProvider): Promise<NestedTransactionMetadata>;
export declare function isEip7702SetCodeTx(txMeta: EthereumTransactionMeta): boolean;
/**
 * Check if a transaction is a EIP-7702 upgrade with data to self transaction.
 * Example: batch transactions with EIP5792 `wallet_sendCalls` method with EIP-7702 upgrade.
 *
 * @example
 * ```json
 * {
 *   "from": "0x1234567890123456789012345678901234567890",
 *   "to": "0x1234567890123456789012345678901234567890",
 *   "data": "0xdeadbeef", // ERC7821 execute batch function data
 *   "type": "0x04",
 *   "authorizationList": [
 *     {
 *       "address": "0x1234567890123456789012345678901234567890",
 *       "chainId": "0x1",
 *       "nonce": "0x1"
 *     }
 *   ]
 * }
 * ```
 * @param txMeta - The transaction metadata
 * @returns true if it's a EIP-7702 upgrade with data to self transaction
 */
export declare function isEip7702UpgradeWithDataToSelfTransaction(txMeta: EthereumTransactionMeta): boolean;
export {};
