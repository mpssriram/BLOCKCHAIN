{"version":3,"sources":["../src/write.ts","../src/smartAccountsEnvironment.ts","../src/userOp.ts"],"sourcesContent":["import { SimpleFactory, DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport { encodePermissionContexts } from './delegation';\nimport type { ExecutionStruct, ExecutionMode } from './executions';\nimport { encodeExecutionCalldatas } from './executions';\nimport type { Delegation, ContractMetaData, Redemption } from './types';\n\n/**\n * Deploys a contract using the SimpleFactory contract.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for simulation.\n * @param simpleFactoryAddress - The address of the SimpleFactory contract.\n * @param creationCode - The creation code for the contract to deploy.\n * @param salt - The salt to use for deterministic deployment.\n * @returns The transaction hash of the deployment.\n */\nexport const deployWithSimpleFactory = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  simpleFactoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: simpleFactoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Redeems a delegation to execute the provided executions.\n * @param walletClient - The wallet client to use for redemption.\n * @param publicClient - The public client to use for simulation.\n * @param delegationManagerAddress - The address of the DelegationManager contract.\n * @param redemptions - The redemptions to execute, containing permission contexts, executions, and modes.\n * @returns The transaction hash of the redemption.\n */\nexport const redeemDelegations = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  delegationManagerAddress: Address,\n  redemptions: Redemption[],\n) => {\n  if (redemptions.length === 0) {\n    throw new Error('RedeemDelegations invalid zero redemptions');\n  }\n\n  const permissionContexts: Delegation[][] = [];\n  const executionsBatch: ExecutionStruct[][] = [];\n  const executionModes: ExecutionMode[] = [];\n\n  redemptions.forEach((redemption) => {\n    permissionContexts.push(redemption.permissionContext);\n    executionsBatch.push(redemption.executions);\n    executionModes.push(redemption.mode);\n  });\n\n  const encodedPermissionContexts =\n    encodePermissionContexts(permissionContexts);\n  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);\n\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: delegationManagerAddress,\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [encodedPermissionContexts, executionModes, executionCalldatas],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Deploys a contract to the blockchain.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for transaction receipt.\n * @param chain - The chain to deploy on.\n * @param contractMetadata - The metadata of the contract to deploy.\n * @param contractMetadata.bytecode - The bytecode of the contract to deploy.\n * @param contractMetadata.abi - The ABI of the contract to deploy.\n * @param args - The constructor arguments for the contract.\n * @returns An object containing the deployed contract address, transaction hash, and receipt.\n */\nexport async function deployContract(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  { bytecode, abi }: ContractMetaData,\n  args: any[] = [],\n) {\n  if (!walletClient.account) {\n    throw new Error('Wallet client account is required');\n  }\n\n  const hash = await walletClient.deployContract({\n    abi,\n    bytecode,\n    args,\n    account: walletClient.account,\n    chain,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  if (!receipt.contractAddress) {\n    throw new Error('No contract address in receipt');\n  }\n\n  return { address: receipt.contractAddress, hash, receipt };\n}\n","import {\n  EntryPoint,\n  SimpleFactory,\n  DelegationManager,\n  MultiSigDeleGator,\n  HybridDeleGator,\n  EIP7702StatelessDeleGator,\n  SCL_RIP7212,\n  AllowedTargetsEnforcer,\n  AllowedMethodsEnforcer,\n  DeployedEnforcer,\n  TimestampEnforcer,\n  NonceEnforcer,\n  AllowedCalldataEnforcer,\n  BlockNumberEnforcer,\n  LimitedCallsEnforcer,\n  ERC20BalanceChangeEnforcer,\n  ERC20StreamingEnforcer,\n  IdEnforcer,\n  ERC20TransferAmountEnforcer,\n  ValueLteEnforcer,\n  NativeTokenTransferAmountEnforcer,\n  NativeBalanceChangeEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenPaymentEnforcer,\n  RedeemerEnforcer,\n  ArgsEqualityCheckEnforcer,\n  ERC721BalanceChangeEnforcer,\n  ERC721TransferEnforcer,\n  ERC1155BalanceChangeEnforcer,\n  OwnershipTransferEnforcer,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  ExactCalldataBatchEnforcer,\n  ExactCalldataEnforcer,\n  ExactExecutionEnforcer,\n  ExactExecutionBatchEnforcer,\n  MultiTokenPeriodEnforcer,\n} from '@metamask/delegation-abis';\nimport { DELEGATOR_CONTRACTS } from '@metamask/delegation-deployments';\nimport type { Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport type { ContractMetaData, SmartAccountsEnvironment } from './types';\nimport { deployContract } from './write';\n\ntype SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';\nexport const PREFERRED_VERSION: SupportedVersion = '1.3.0';\n\nconst contractOverrideMap: Map<string, SmartAccountsEnvironment> = new Map();\n\nconst getContractOverrideKey = (chainId: number, version: SupportedVersion) =>\n  `${version}:${chainId}`;\n\n/**\n * Overrides the default environment for a specific chain and version.\n * @param chainId - The chain ID to override.\n * @param version - The version of the environment to override.\n * @param environment - The environment to use as override.\n */\nexport function overrideDeployedEnvironment(\n  chainId: number,\n  version: SupportedVersion,\n  environment: SmartAccountsEnvironment,\n) {\n  contractOverrideMap.set(\n    getContractOverrideKey(chainId, version),\n    environment,\n  );\n}\n\n/**\n * Gets the SmartAccountsEnvironment for the specified chain and version.\n * @param chainId - The chain ID to get the environment for.\n * @param version - The version of the environment to get.\n * @returns The SmartAccountsEnvironment.\n */\nexport function getSmartAccountsEnvironment(\n  chainId: number,\n  version: SupportedVersion = PREFERRED_VERSION,\n): SmartAccountsEnvironment {\n  const overrideKey = getContractOverrideKey(chainId, version);\n\n  const overriddenContracts = contractOverrideMap.get(overrideKey);\n  if (overriddenContracts) {\n    return overriddenContracts;\n  }\n\n  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];\n  if (!contracts) {\n    throw new Error(\n      `No contracts found for version ${version} chain ${chainId}`,\n    );\n  }\n  return getSmartAccountsEnvironmentV1(contracts);\n}\n\n/**\n * Creates a SmartAccountsEnvironment from contract addresses.\n * @param contracts - The contract addresses to create the environment from.\n * @returns The created SmartAccountsEnvironment.\n */\nexport function getSmartAccountsEnvironmentV1(contracts: {\n  [contract: string]: Hex;\n}) {\n  return {\n    DelegationManager: contracts.DelegationManager,\n    EntryPoint: contracts.EntryPoint,\n    SimpleFactory: contracts.SimpleFactory,\n    implementations: {\n      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,\n      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,\n      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl,\n    },\n    caveatEnforcers: {\n      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,\n      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,\n      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,\n      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,\n      BlockNumberEnforcer: contracts.BlockNumberEnforcer,\n      DeployedEnforcer: contracts.DeployedEnforcer,\n      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,\n      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,\n      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,\n      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,\n      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,\n      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,\n      IdEnforcer: contracts.IdEnforcer,\n      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,\n      NonceEnforcer: contracts.NonceEnforcer,\n      TimestampEnforcer: contracts.TimestampEnforcer,\n      ValueLteEnforcer: contracts.ValueLteEnforcer,\n      NativeTokenTransferAmountEnforcer:\n        contracts.NativeTokenTransferAmountEnforcer,\n      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,\n      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,\n      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,\n      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,\n      RedeemerEnforcer: contracts.RedeemerEnforcer,\n      SpecificActionERC20TransferBatchEnforcer:\n        contracts.SpecificActionERC20TransferBatchEnforcer,\n      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,\n      NativeTokenPeriodTransferEnforcer:\n        contracts.NativeTokenPeriodTransferEnforcer,\n      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,\n      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,\n      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,\n      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,\n      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer,\n    },\n  } as SmartAccountsEnvironment;\n}\n\nexport type DeployedContract = {\n  name: string;\n  address: string;\n};\n\n/**\n * Deploys the contracts needed for the Delegation Framework and MetaMask SCA to be functional as well as all Caveat Enforcers.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for deployment.\n * @param chain - The chain to deploy to.\n * @param deployedContracts - Optional map of already deployed contracts.\n * @returns A promise that resolves to the SmartAccountsEnvironment.\n */\nexport async function deploySmartAccountsEnvironment(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  deployedContracts: { [contract: string]: Hex } = {},\n) {\n  const deployContractCurried = async (\n    name: string,\n    contract: ContractMetaData,\n    params: any[] = [],\n  ) => {\n    const existingAddress = deployedContracts[name];\n    if (existingAddress) {\n      return {\n        address: existingAddress,\n        name,\n      };\n    }\n\n    const deployedContract = await deployContract(\n      walletClient,\n      publicClient,\n      chain,\n      contract,\n      params,\n    );\n\n    const newDeployedContracts = { ...deployedContracts };\n    newDeployedContracts[name] = deployedContract.address;\n    Object.assign(deployedContracts, newDeployedContracts);\n\n    return { ...deployedContract, name };\n  };\n\n  // Deploy v1.3.0 DeleGator contracts\n  // - deploy standalone contracts\n  const standaloneContracts = {\n    SimpleFactory,\n    AllowedCalldataEnforcer,\n    AllowedTargetsEnforcer,\n    AllowedMethodsEnforcer,\n    ArgsEqualityCheckEnforcer,\n    DeployedEnforcer,\n    TimestampEnforcer,\n    BlockNumberEnforcer,\n    LimitedCallsEnforcer,\n    ERC20BalanceChangeEnforcer,\n    ERC20TransferAmountEnforcer,\n    ERC20StreamingEnforcer,\n    ERC721BalanceChangeEnforcer,\n    ERC721TransferEnforcer,\n    ERC1155BalanceChangeEnforcer,\n    IdEnforcer,\n    NonceEnforcer,\n    ValueLteEnforcer,\n    NativeTokenTransferAmountEnforcer,\n    NativeBalanceChangeEnforcer,\n    NativeTokenStreamingEnforcer,\n    OwnershipTransferEnforcer,\n    RedeemerEnforcer,\n    SpecificActionERC20TransferBatchEnforcer,\n    ERC20PeriodTransferEnforcer,\n    NativeTokenPeriodTransferEnforcer,\n    ExactCalldataBatchEnforcer,\n    ExactCalldataEnforcer,\n    ExactExecutionEnforcer,\n    ExactExecutionBatchEnforcer,\n    MultiTokenPeriodEnforcer,\n  };\n  for (const [name, contract] of Object.entries(standaloneContracts)) {\n    await deployContractCurried(name, contract);\n  }\n\n  // - deploy dependencies\n  const delegationManager = await deployContractCurried(\n    'DelegationManager',\n    DelegationManager,\n    [walletClient.account?.address],\n  );\n\n  // - NativeTokenPaymentEnforcer DelegationManager and ArgsEqualityCheckEnforcer as constructor args\n  await deployContractCurried(\n    'NativeTokenPaymentEnforcer',\n    NativeTokenPaymentEnforcer,\n    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer],\n  );\n\n  const entryPoint = await deployContractCurried('EntryPoint', EntryPoint);\n\n  // This is a hack to work around the SCL_RIP7212 being deployed as a library.\n  // Forge handles this gracefully, but in the tests we need to manually link\n  // the library.\n  // We don't use the curried function here because we don't need it added to\n  // the environment.\n  const { address: sclRIP7212 } = await deployContract(\n    walletClient,\n    publicClient,\n    chain,\n    SCL_RIP7212,\n    [],\n  );\n\n  // replace linked library address in bytecode https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking\n  const hybridDeleGatorWithLinkedLibrary = {\n    ...HybridDeleGator,\n    bytecode: HybridDeleGator.bytecode.replace(\n      /__\\$b8f96b288d4d0429e38b8ed50fd423070f\\$__/gu,\n      sclRIP7212.slice(2),\n    ) as Hex,\n  };\n\n  // - deploy DeleGator implementations\n  await deployContractCurried(\n    'HybridDeleGatorImpl',\n    hybridDeleGatorWithLinkedLibrary,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  await deployContractCurried('MultiSigDeleGatorImpl', MultiSigDeleGator, [\n    delegationManager.address,\n    entryPoint.address,\n  ]);\n\n  await deployContractCurried(\n    'EIP7702StatelessDeleGatorImpl',\n    EIP7702StatelessDeleGator,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  // Format deployments\n  return getSmartAccountsEnvironmentV1(deployedContracts);\n}\n","import { concat, encodeAbiParameters, keccak256, pad, toHex } from 'viem';\nimport type { Address, Hex, TypedData } from 'viem';\nimport { toPackedUserOperation } from 'viem/account-abstraction';\nimport { signTypedData } from 'viem/accounts';\n\nimport type { OptionalUserOpProps, PackedUserOperationStruct } from './types';\n\n// v7 off-chain user operation, hexlified incoming data from rpc call\nexport type UserOperationV07Hexlify = {\n  sender: Hex;\n  nonce: Hex;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: Hex;\n  paymasterPostOpGasLimit?: Hex;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n// v7 off-chain user operation with BigInt fields\nexport type UserOperationV07 = {\n  sender: Hex;\n  nonce: bigint;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n/**\n * Creates a raw user operation data structure.\n * @param sender - The smart account taking some action.\n * @param nonce - A nonce, ideally fetched from the Entry Point.\n * @param callData - Calldata to invoke on some contract.\n * @param signature - The signature for the user operation.\n * @param options - Optional properties for the user operation.\n * @returns The created raw user operation data structure.\n */\nexport const createRawUserOp = (\n  sender: Hex,\n  nonce: bigint,\n  callData: Hex,\n  signature: Hex = '0x',\n  options?: OptionalUserOpProps,\n): UserOperationV07 => ({\n  sender,\n  nonce,\n  callData,\n  factory: options?.factory,\n  factoryData: options?.factoryData,\n  callGasLimit: options?.callGasLimit ?? 0n,\n  verificationGasLimit: options?.verificationGasLimit ?? 0n,\n  preVerificationGas: options?.preVerificationGas ?? 0n,\n  maxFeePerGas: options?.maxFeePerGas ?? 0n,\n  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,\n  paymaster: options?.paymaster,\n  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,\n  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,\n  paymasterData: options?.paymasterData,\n  signature,\n});\n\n// //////////////////////////////////////////////////////////////////////////////////////\n\n// TODO: These userOp functions are duplicated in ./apps/ew-client/src/utils/userOpBuilder.ts. We should move them to a shared location along with test(./apps/ew-client/test/UserOpBuilder.test.ts) to avoid duplication\n/**\n * Generates a salt value for address derivation.\n * @param salt - Optional salt value.\n * @returns The chosen salt value.\n */\nexport const getSalt = (salt?: Hex): Hex => {\n  return salt ?? '0x0';\n};\n\nexport const getPaymasterAndData = (userOp: UserOperationV07): Hex => {\n  let paymasterAndData: Hex;\n  if (userOp.paymaster) {\n    paymasterAndData = concat([\n      userOp.paymaster,\n      pad(toHex(userOp.paymasterVerificationGasLimit ?? 0n), {\n        size: 16,\n      }),\n      pad(toHex(userOp.paymasterPostOpGasLimit ?? 0n), {\n        size: 16,\n      }),\n      userOp.paymasterData ?? '0x',\n    ]);\n  } else {\n    paymasterAndData = '0x';\n  }\n\n  return paymasterAndData;\n};\n\nexport const getInitCode = (userOp: UserOperationV07): Hex => {\n  return userOp.factory\n    ? concat([userOp.factory, userOp.factoryData ?? ('0x' as Hex)])\n    : '0x';\n};\n\nexport const getAccountGasLimits = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(userOp.callGasLimit), { size: 16 }),\n  ]);\n};\n\nexport const getGasFees = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(userOp.maxFeePerGas), { size: 16 }),\n  ]);\n};\n\n/**\n * Packs a user operation into a `PackedUserOperationStruct` object.\n *\n * @param userOp - The user operation to pack.\n * @returns The packed user operation.\n */\nexport const packUserOp = (\n  userOp: UserOperationV07,\n): PackedUserOperationStruct => {\n  const packedOp = {\n    sender: userOp.sender,\n    nonce: BigInt(userOp.nonce),\n    initCode: getInitCode(userOp),\n    callData: userOp.callData,\n    accountGasLimits: getAccountGasLimits(userOp),\n    preVerificationGas: BigInt(userOp.preVerificationGas),\n    gasFees: getGasFees(userOp),\n    paymasterAndData: getPaymasterAndData(userOp),\n    signature: userOp.signature,\n  };\n\n  return packedOp;\n};\n\n/**\n * Calculates the user operation hash for a given packed user operation.\n * @param packedOp - The packed user operation.\n * @param entryPoint - The entry point address.\n * @param chainId - The chain ID.\n * @returns The user operation hash.\n */\nexport const createUserOpHashV07 = (\n  packedOp: PackedUserOperationStruct,\n  entryPoint: Hex,\n  chainId: bigint,\n) => {\n  const hash = keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'sender',\n          type: 'address',\n        },\n        {\n          name: 'nonce',\n          type: 'uint256',\n        },\n        {\n          name: 'initCodeHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'callDataHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'accountGasLimits',\n          type: 'bytes32',\n        },\n        {\n          name: 'preVerificationGas',\n          type: 'uint256',\n        },\n        {\n          name: 'gasFees',\n          type: 'bytes32',\n        },\n        {\n          name: 'paymasterAndDataHash',\n          type: 'bytes32',\n        },\n      ],\n      [\n        packedOp.sender,\n        packedOp.nonce,\n        keccak256(packedOp.initCode),\n        keccak256(packedOp.callData),\n        packedOp.accountGasLimits,\n        packedOp.preVerificationGas,\n        packedOp.gasFees,\n        keccak256(packedOp.paymasterAndData),\n      ],\n    ),\n  );\n\n  return keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'userOpHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'entryPointAddress',\n          type: 'address',\n        },\n        {\n          name: 'chainId',\n          type: 'uint256',\n        },\n      ],\n      [hash, entryPoint, chainId],\n    ),\n  );\n};\n\nexport const SIGNABLE_USER_OP_TYPED_DATA: TypedData = {\n  PackedUserOperation: [\n    { name: 'sender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'initCode', type: 'bytes' },\n    { name: 'callData', type: 'bytes' },\n    { name: 'accountGasLimits', type: 'bytes32' },\n    { name: 'preVerificationGas', type: 'uint256' },\n    { name: 'gasFees', type: 'bytes32' },\n    { name: 'paymasterAndData', type: 'bytes' },\n    { name: 'entryPoint', type: 'address' },\n  ],\n} as const;\n\n/**\n * Prepares typed data for user operation signing.\n * This is an internal helper function that's not exposed in the public API.\n *\n * @param params - The parameters for preparing the typed data.\n * @param params.userOperation - The user operation to prepare for signing.\n * @param params.entryPoint - The entry point contract address.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @returns The prepared typed data for signing.\n */\nexport const prepareSignUserOperationTypedData = ({\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  address: Address;\n  version?: string;\n}) => {\n  const packedUserOp = toPackedUserOperation({\n    ...userOperation,\n    signature: '0x',\n  });\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: address,\n    },\n    types: SIGNABLE_USER_OP_TYPED_DATA,\n    primaryType: 'PackedUserOperation' as const,\n    message: { ...packedUserOp, entryPoint: entryPoint.address },\n  };\n};\n\n/**\n * Signs a user operation using a private key.\n * @param params - The parameters for signing the user operation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.userOperation - The user operation to sign.\n * @param params.entryPoint - The entry point contract address.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @returns The signature of the user operation.\n */\nexport const signUserOperation = async ({\n  privateKey,\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  privateKey: Hex;\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  address: Address;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  version?: string;\n}) => {\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n"],"mappings":"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","names":["SimpleFactory","DelegationManager","SimpleFactory","DelegationManager"]}