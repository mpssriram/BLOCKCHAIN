import { encode } from '@ethereumjs/rlp';
import { addHexPrefix, bytesToHex, privateToPublic, toChecksumAddress, privateToAddress, stripHexPrefix, bigIntToBytes, isHexString } from '@ethereumjs/util';
import { BaseKeyringController, ecsignature, concatSig } from '@toruslabs/base-controllers';
import { SigningKey, concat, keccak256, hashMessage, TypedDataEncoder } from 'ethers';
import { toHex } from 'viem';

class KeyringController extends BaseKeyringController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    this.defaultState = {
      wallets: []
    };
    this.initialize();
  }
  async signTransaction(tx, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    const localTx = tx;
    localTx.signature = privKey.sign(localTx.unsignedHash);
    return localTx;
  }
  async signEip7702Authorization(authorization, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));

    // Convert hex strings to proper types for RLP encoding
    // EIP-7702 authorization tuple: [chain_id_decimal, address, nonce_decimal]
    const chainIdDecimal = parseInt(authorization.chainId, 16);
    const nonceDecimal = parseInt(authorization.nonce, 16);

    // RLP encode the eip7702 authorization
    const encodedAuthorization = encode([chainIdDecimal, authorization.address, nonceDecimal]);
    // Prefixed with EIP7702 Domain Separator (0x05)
    const prefixedAuthorization = concat(["0x05", encodedAuthorization]);
    const authorizationHash = keccak256(prefixedAuthorization);
    const {
      r,
      s,
      v
    } = privKey.sign(authorizationHash);
    const signedAuthorization = {
      address: authorization.address,
      chainId: authorization.chainId,
      nonce: authorization.nonce,
      r: addHexPrefix(r),
      s: addHexPrefix(s),
      yParity: toHex(v - 27 === 0 ? 0 : 1)
    };
    return signedAuthorization;
  }
  getAccounts() {
    return this.state.wallets.map(w => w.publicKey);
  }
  importAccount(accountPrivateKey) {
    try {
      const hexPrivateKey = accountPrivateKey.padStart(64, "0");
      const bufferPrivKey = Buffer.from(hexPrivateKey, "hex");
      const publicKey = bytesToHex(privateToPublic(bufferPrivKey));
      const address = toChecksumAddress(bytesToHex(privateToAddress(bufferPrivKey)));
      const existingWallet = this.state.wallets.find(w => w.address === address);
      if (existingWallet) return existingWallet.address;
      this.update({
        wallets: [...this.state.wallets, {
          publicKey,
          privateKey: accountPrivateKey,
          address
        }]
      });
      return address;
    } catch (error) {
      if (error instanceof Error && error.message.includes("expected 32 bytes")) {
        throw new Error("invalid private key, expected hex or");
      }
      throw error;
    }
  }
  removeAccount(address) {
    const newWallets = [...this.state.wallets];
    const idx = newWallets.findIndex(w => w.address === address);
    if (idx !== -1) {
      newWallets.splice(idx, 1);
      this.update({
        wallets: newWallets
      });
    }
  }
  getBufferPrivateKey(privateKey) {
    const stripped = stripHexPrefix(privateKey);
    return Buffer.from(stripped, "hex");
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const messageSig = ecsignature(Buffer.from(stripHexPrefix(data), "hex"), privKey);
    const sig = concatSig(Buffer.from(bigIntToBytes(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));
    return sig;
  }
  async signPersonalMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    // we need to check if the data is hex or not
    // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
    // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
    const message = isHexString(data) ? Buffer.from(stripHexPrefix(data), "hex") : Buffer.from(data);
    const signature = privKey.sign(hashMessage(message)).serialized;
    return signature;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(typedData, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    delete typedData.types.EIP712Domain;
    const signature = privKey.sign(TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)).serialized;
    return signature;
  }
  _getWalletForAccount(account) {
    const address = account.toLowerCase();
    const wallet = this.state.wallets.find(w => w.address.toLowerCase() === address);
    if (!wallet) throw new Error("Torus Keyring - Unable to find matching address.");
    return wallet;
  }
}

export { KeyringController };
