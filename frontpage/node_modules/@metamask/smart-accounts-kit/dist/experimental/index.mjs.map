{"version":3,"sources":["../../src/experimental/delegationStorage.ts"],"sourcesContent":["import { type Hex, toHex } from 'viem';\n\nimport { getDelegationHashOffchain } from '../delegation';\nimport type { Delegation } from '../types';\n\ntype ErrorResponse = {\n  error: string;\n  data?: any;\n};\n\nexport type APIStoreDelegationResponse = {\n  delegationHash: Hex;\n};\n\n/**\n * Represents the allowed filters when querying the data store for delegations.\n */\nexport enum DelegationStoreFilter {\n  Given = 'GIVEN',\n  Received = 'RECEIVED',\n  All = 'ALL',\n}\n\n/**\n * Public Delegation Storage Service environments. To be used in the\n * DeleGationStorageService config.\n */\nexport const DelegationStorageEnvironment: {\n  [K in 'dev' | 'prod']: Environment;\n} = {\n  dev: { apiUrl: 'https://passkeys.dev-api.cx.metamask.io' },\n  prod: { apiUrl: 'https://passkeys.api.cx.metamask.io' },\n};\n\nexport type Environment = {\n  apiUrl: string;\n};\n\nexport type DelegationStorageConfig = {\n  apiKey: string;\n  apiKeyId: string;\n  environment: Environment;\n  fetcher?: typeof fetch;\n};\n\nexport class DelegationStorageClient {\n  #apiVersionPrefix = 'api/v0';\n\n  #config: DelegationStorageConfig;\n\n  #fetcher: typeof fetch;\n\n  #apiUrl: string;\n\n  constructor(config: DelegationStorageConfig) {\n    const { apiUrl } = config.environment;\n\n    if (apiUrl.endsWith(this.#apiVersionPrefix)) {\n      this.#apiUrl = apiUrl;\n    } else {\n      const separator = apiUrl.endsWith('/') ? '' : '/';\n      this.#apiUrl = `${apiUrl}${separator}${this.#apiVersionPrefix}`;\n    }\n    this.#fetcher = this.#initializeFetcher(config);\n    this.#config = config;\n  }\n\n  /**\n   * Initializes the fetch function for HTTP requests.\n   *\n   * - Uses `config.fetcher` if provided.\n   * - Falls back to global `fetch` if available.\n   * - Throws an error if no fetch function is available.\n   *\n   * @param config - Configuration object that may include a custom fetch function.\n   * @returns The fetch function to be used for HTTP requests.\n   * @throws Error if no fetch function is available in the environment.\n   */\n  #initializeFetcher(config: DelegationStorageConfig): typeof fetch {\n    if (config.fetcher) {\n      return config.fetcher;\n    } else if (typeof globalThis?.fetch === 'function') {\n      return globalThis.fetch.bind(globalThis);\n    }\n    throw new Error(\n      'Fetch API is not available in this environment. Please provide a fetch function in the config.',\n    );\n  }\n\n  /**\n   * Fetches the delegation chain from the Delegation Storage Service, ending with\n   * the specified leaf delegation.\n   *\n   * @param leafDelegationOrDelegationHash - The leaf delegation, or the hash\n   * of the leaf delegation.\n   * @returns A promise that resolves to the delegation chain - empty array if the delegation\n   * is not found.\n   */\n  async getDelegationChain(\n    leafDelegationOrDelegationHash: Hex | Delegation,\n  ): Promise<Delegation[]> {\n    const leafDelegationHash =\n      typeof leafDelegationOrDelegationHash === 'string'\n        ? leafDelegationOrDelegationHash\n        : getDelegationHashOffchain(leafDelegationOrDelegationHash);\n\n    const response = await this.#fetcher(\n      `${this.#apiUrl}/delegation/chain/${leafDelegationHash}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.#config.apiKey}`,\n          'x-api-key-id': this.#config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(\n        `Failed to fetch delegation chain: ${responseData.error}`,\n      );\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Fetches the delegations from the Delegation Storage Service, either `Received`\n   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults\n   * to `Received`.\n   *\n   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.\n   * @param filterMode - The DelegationStoreFilter mode - defaults to Received.\n   * @returns A promise that resolves to the list of delegations received by the deleGatorAddress,\n   * empty array if the delegations are not found.\n   */\n  async fetchDelegations(\n    deleGatorAddress: Hex,\n    filterMode = DelegationStoreFilter.Received,\n  ): Promise<Delegation[]> {\n    const response = await this.#fetcher(\n      `${this.#apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.#config.apiKey}`,\n          'x-api-key-id': this.#config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(`Failed to fetch delegations: ${responseData.error}`);\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Stores the specified delegation in the Delegation Storage Service.\n   *\n   * @param delegation - The delegation to store.\n   * @returns A promise that resolves to the delegation hash indicating successful storage.\n   */\n  async storeDelegation(delegation: Delegation): Promise<Hex> {\n    if (!delegation.signature || delegation.signature === '0x') {\n      throw new Error('Delegation must be signed to be stored');\n    }\n\n    const delegationHash = getDelegationHashOffchain(delegation);\n\n    const body = JSON.stringify(\n      {\n        ...delegation,\n        metadata: [],\n      },\n      (_, value: any) =>\n        typeof value === 'bigint' || typeof value === 'number'\n          ? toHex(value)\n          : value,\n      2,\n    );\n\n    const response = await this.#fetcher(`${this.#apiUrl}/delegation/store`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this.#config.apiKey}`,\n        'x-api-key-id': this.#config.apiKeyId,\n        'Content-Type': 'application/json',\n      },\n      body,\n    });\n\n    const responseData: APIStoreDelegationResponse | ErrorResponse =\n      await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(responseData.error);\n    }\n\n    if (responseData.delegationHash !== delegationHash) {\n      throw Error(\n        'Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation',\n      );\n    }\n\n    return responseData.delegationHash;\n  }\n}\n"],"mappings":"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","names":[]}