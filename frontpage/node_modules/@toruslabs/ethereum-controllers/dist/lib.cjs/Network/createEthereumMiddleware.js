'use strict';

var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var walletGetCallsStatus = require('../Eip5792/walletGetCallsStatus.js');
var walletGetCapabilities = require('../Eip5792/walletGetCapabilities.js');
var walletSendCalls = require('../Eip5792/walletSendCalls.js');
var walletGetUpgradeStatus = require('../Eip7702/walletGetUpgradeStatus.js');
var walletUpgradeAccount = require('../Eip7702/walletUpgradeAccount.js');
var constants = require('../utils/constants.js');
var eip5792Types = require('../utils/eip5792Types.js');
var eip7702Types = require('../utils/eip7702Types.js');
var transaction = require('../utils/transaction.js');

function createGetAccountsMiddleware({
  getAccounts
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    const accounts = await getAccounts(request);
    response.result = accounts;
  });
}
function createProcessTransactionMiddleware({
  processTransaction
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_TRANSACTION) return next();
    if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");
    response.result = await processTransaction(request.params, request);
  });
}
function createProcessSignTransactionMiddleware({
  processSignTransaction
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN_TRANSACTION) return next();
    if (!processSignTransaction) throw new Error("WalletMiddleware - opts.processSignTransaction not provided");
    response.result = await processSignTransaction(request.params, request);
  });
}
function createProcessEstimateUserOperationGasMiddleware({
  processEstimateUserOperationGas
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_ESTIMATE_AA_TRANSACTION_GAS) return next();
    if (!processEstimateUserOperationGas) throw new Error("WalletMiddleware - opts.processEstimateUserOperationGas not provided");
    response.result = await processEstimateUserOperationGas(request.params, request);
  });
}
function createProcessEthSignMessage({
  processEthSignMessage
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN) return next();
    if (!processEthSignMessage) throw new Error("WalletMiddleware - opts.processEthSignMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processEthSignMessage(msgParams, request);
  });
}
function createProcessTypedMessageV4({
  processTypedMessageV4
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();
    if (!processTypedMessageV4) throw new Error("WalletMiddleware - opts.processTypedMessageV4 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processTypedMessageV4(msgParams, request);
  });
}
function createProcessPersonalMessage({
  processPersonalMessage
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.PERSONAL_SIGN) return next();
    if (!processPersonalMessage) throw new Error("WalletMiddleware - opts.processPersonalMessage is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const params = request.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    response.result = await processPersonalMessage(msgParams, request);
  });
}
function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();
    const {
      blockReference
    } = params;
    if (blockReference !== "pending") return next();
    response.result = await getPendingNonce(params, request);
  });
}
function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    txReceipt,
    transaction,
    transactionHash,
    accessList
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = transaction;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash: transactionHash,
    nonce,
    input: data || "0x",
    value: value || "0x0",
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null,
    type: null
  };
  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = constants.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = constants.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }
  return formattedTxMeta;
}
function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();
    if (!getPendingTransactionByHash) throw new Error("WalletMiddleware - opts.getPendingTransactionByHash not provided");
    const txMeta = await getPendingTransactionByHash(params, request);
    if (!txMeta) {
      return next();
    }
    response.result = formatTxMetaForRpcResult(txMeta);
    return undefined;
  });
}
function createProcessSwitchEthereumChain({
  processSwitchEthereumChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.SWITCH_CHAIN) return next();
    if (!processSwitchEthereumChain) throw new Error("WalletMiddleware - opts.processSwitchEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processSwitchEthereumChain(msgParams, request);
  });
}
function createProcessWalletSwitchChain({
  processWalletSwitchChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== baseControllers.PROVIDER_JRPC_METHODS.WALLET_SWITCH_CHAIN) return next();
    if (!processWalletSwitchChain) throw new Error("WalletMiddleware - opts.processWalletSwitchChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processWalletSwitchChain(msgParams, request);
  });
}
function createProcessAddEthereumChain({
  processAddEthereumChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ADD_CHAIN) return next();
    if (!processAddEthereumChain) throw new Error("WalletMiddleware - opts.processAddEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processAddEthereumChain(msgParams, request);
  });
}
function createRequestAccountsMiddleware({
  requestAccounts
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "eth_requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
/**
 * Middleware to handle bundler/paymaster rpc method
 */
function createAAMiddleware({
  bundlerUrl,
  paymasterUrl,
  providerConfig,
  analytics
}) {
  // forward request to bundler/paymaster
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const middlewares = [];
  // NOTE: bundler/paymaster rpc only accept number as request id, we need to handle that here if client doesn't handle request id themselves
  const idNumberRemapMiddleware = (req, res, next, _end) => {
    // skip if not bundler/paymaster methods
    if (!constants.BUNDLER_METHOD_TYPES.includes(req.method) && !constants.PAYMASTER_METHOD_TYPES.includes(req.method)) {
      return next();
    }
    const originalId = req.id;
    const newId = Math.floor(Math.random() * 1000000);
    req.id = newId;
    res.id = newId;
    next(done => {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
  const bundlerFetchMiddleware = baseControllers.createFetchMiddleware({
    rpcTarget: bundlerUrl,
    providerConfig,
    analytics,
    transactionDecoder: transaction.transactionDecoder
  });
  middlewares.push(idNumberRemapMiddleware);
  middlewares.push((request, response, next, end) => {
    if (!constants.BUNDLER_METHOD_TYPES.includes(request.method)) {
      return next();
    }
    bundlerFetchMiddleware(request, response, next, end);
  });
  if (paymasterUrl) {
    const paymasterFetchMiddleware = baseControllers.createFetchMiddleware({
      rpcTarget: paymasterUrl,
      providerConfig,
      analytics,
      transactionDecoder: transaction.transactionDecoder
    });
    middlewares.push((request, response, next, end) => {
      if (!constants.PAYMASTER_METHOD_TYPES.includes(request.method)) {
        return next();
      }
      paymasterFetchMiddleware(request, response, next, end);
    });
  }
  return auth.mergeMiddleware(middlewares);
}
/**
 * Middleware to handle EIP-7702 methods.
 *
 * @param getEthCode - Function to get the deployment bytecode of an address. (eth_getCode)
 * @param processTransaction - Function to process a transaction.
 * @returns JRPCMiddleware to handle EIP-7702 methods
 */
function createEip7702Middleware({
  getEthCode,
  processTransaction
}) {
  return auth.createScaffoldMiddleware({
    [eip7702Types.EIP_7702_METHODS.WALLET_UPGRADE_ACCOUNT]: auth.createAsyncMiddleware(async (request, response, next) => {
      if (request.method !== eip7702Types.EIP_7702_METHODS.WALLET_UPGRADE_ACCOUNT) {
        return next();
      }
      if (!getEthCode) throw new Error("WalletMiddleware - opts.getEthCode not provided");
      if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");
      const result = await walletUpgradeAccount.walletUpgradeAccount(request, getEthCode, processTransaction);
      response.result = result;
    }),
    [eip7702Types.EIP_7702_METHODS.WALLET_GET_ACCOUNT_UPGRADE_STATUS]: auth.createAsyncMiddleware(async (request, response, next) => {
      if (request.method !== eip7702Types.EIP_7702_METHODS.WALLET_GET_ACCOUNT_UPGRADE_STATUS) {
        return next();
      }
      if (!getEthCode) {
        throw new Error("getEthCode not provided");
      }
      const result = await walletGetUpgradeStatus.walletGetUpgradeStatus(request, getEthCode);
      response.result = result;
    })
  });
}
/**
 * Middleware to handle EIP-5792 methods.
 * Supports wallet capabilities and batch call operations for EIP-7702 upgraded accounts.
 *
 * @param eip5792Config - Configuration for EIP-5792 handlers.
 * @param processTransaction - Function to process a transaction.
 * @returns JRPCMiddleware to handle EIP-5792 methods
 */
function createEip5792Middleware({
  eip5792Config,
  processTransaction,
  processTransactionBatch,
  getTransactionByBatchId,
  getEthCode
}) {
  if (!eip5792Config) {
    // Return a pass-through middleware if EIP-5792 is not configured
    return (_req, _res, next) => next();
  }
  const {
    getSupportedChains,
    getCachedDelegations,
    updateDelegationCache
  } = eip5792Config;
  // Context for wallet_getCapabilities
  const getCapabilitiesContext = {
    getSupportedChains,
    getCachedDelegations,
    updateDelegationCache
  };
  // Context for wallet_sendCalls
  const sendCallsContext = {
    processTransactionBatch
  };
  return auth.createScaffoldMiddleware({
    [eip5792Types.EIP_5792_METHODS.WALLET_GET_CAPABILITIES]: auth.createAsyncMiddleware(async (request, response, next) => {
      if (request.method !== eip5792Types.EIP_5792_METHODS.WALLET_GET_CAPABILITIES) {
        return next();
      }
      const result = await walletGetCapabilities.walletGetCapabilities(request, getEthCode, getCapabilitiesContext);
      response.result = result;
    }),
    [eip5792Types.EIP_5792_METHODS.WALLET_SEND_CALLS]: auth.createAsyncMiddleware(async (request, response, next) => {
      if (request.method !== eip5792Types.EIP_5792_METHODS.WALLET_SEND_CALLS) {
        return next();
      }
      const result = await walletSendCalls.walletSendCalls(request, getEthCode, sendCallsContext);
      response.result = result;
    }),
    [eip5792Types.EIP_5792_METHODS.WALLET_GET_CALLS_STATUS]: auth.createAsyncMiddleware(async (request, response, next) => {
      if (request.method !== eip5792Types.EIP_5792_METHODS.WALLET_GET_CALLS_STATUS) {
        return next();
      }
      const result = walletGetCallsStatus.walletGetCallsStatus(request, getTransactionByBatchId);
      response.result = result;
    })
  });
}
function createEthereumMiddleware(providerHandlers, providerConfig, analytics) {
  const {
    requestAccounts,
    getAccounts,
    getPrivateKey,
    getPublicKey,
    processTransaction,
    processTransactionBatch,
    processSignTransaction,
    processEstimateUserOperationGas,
    processEthSignMessage,
    processTypedMessageV4,
    processPersonalMessage,
    getPendingNonce,
    getPendingTransactionByHash,
    getTransactionByBatchId,
    processSwitchEthereumChain,
    processWalletSwitchChain,
    processAddEthereumChain,
    getProviderState,
    aaConfig,
    version,
    getEthCode,
    eip5792Config
  } = providerHandlers;
  const middlewares = [auth.createScaffoldMiddleware({
    version,
    [baseControllers.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState
  }), createEip7702Middleware({
    getEthCode,
    processTransaction
  }), createEip5792Middleware({
    eip5792Config,
    processTransaction,
    processTransactionBatch,
    getEthCode,
    getTransactionByBatchId
  }), createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.ETH_PRIVATE_KEY, getPrivateKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.PRIVATE_KEY, getPrivateKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.ETH_PUBLIC_KEY, getPublicKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.PUBLIC_KEY, getPublicKey), createProcessTransactionMiddleware({
    processTransaction
  }), createProcessSignTransactionMiddleware({
    processSignTransaction
  }), createProcessEstimateUserOperationGasMiddleware({
    processEstimateUserOperationGas
  }), createProcessEthSignMessage({
    processEthSignMessage
  }), createProcessTypedMessageV4({
    processTypedMessageV4
  }), createProcessPersonalMessage({
    processPersonalMessage
  }), createPendingNonceMiddleware({
    getPendingNonce
  }), createPendingTxMiddleware({
    getPendingTransactionByHash
  }), createProcessSwitchEthereumChain({
    processSwitchEthereumChain
  }), createProcessWalletSwitchChain({
    processWalletSwitchChain
  }), createProcessAddEthereumChain({
    processAddEthereumChain
  })];
  if (aaConfig) {
    middlewares.push(createAAMiddleware({
      bundlerUrl: aaConfig.bundlerUrl,
      paymasterUrl: aaConfig.paymasterUrl,
      providerConfig,
      analytics
    }));
  }
  return auth.mergeMiddleware(middlewares);
}

exports.createAAMiddleware = createAAMiddleware;
exports.createEip5792Middleware = createEip5792Middleware;
exports.createEip7702Middleware = createEip7702Middleware;
exports.createEthereumMiddleware = createEthereumMiddleware;
exports.createGetAccountsMiddleware = createGetAccountsMiddleware;
exports.createPendingNonceMiddleware = createPendingNonceMiddleware;
exports.createPendingTxMiddleware = createPendingTxMiddleware;
exports.createProcessAddEthereumChain = createProcessAddEthereumChain;
exports.createProcessEstimateUserOperationGasMiddleware = createProcessEstimateUserOperationGasMiddleware;
exports.createProcessEthSignMessage = createProcessEthSignMessage;
exports.createProcessPersonalMessage = createProcessPersonalMessage;
exports.createProcessSignTransactionMiddleware = createProcessSignTransactionMiddleware;
exports.createProcessSwitchEthereumChain = createProcessSwitchEthereumChain;
exports.createProcessTransactionMiddleware = createProcessTransactionMiddleware;
exports.createProcessTypedMessageV4 = createProcessTypedMessageV4;
exports.createProcessWalletSwitchChain = createProcessWalletSwitchChain;
exports.createRequestAccountsMiddleware = createRequestAccountsMiddleware;
exports.formatTxMetaForRpcResult = formatTxMetaForRpcResult;
