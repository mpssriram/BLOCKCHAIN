import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { SIGNER_MAP } from '@toruslabs/constants';
import { get } from '@toruslabs/http-helpers';
import { WEB3AUTH_NETWORK, rpcErrors } from '@web3auth/auth';
import log from './loglevel.js';

// utility functions

/**
 * json-rpc-engine middleware that logs RPC errors and and validates req.method.
 *
 * @param log - The logging API to use.
 * @returns  json-rpc-engine middleware function
 */
function createErrorMiddleware() {
  return (req, res, next) => {
    // json-rpc-engine will terminate the request when it notices this error
    if (typeof req.method !== "string" || !req.method) {
      res.error = rpcErrors.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: _objectSpread(_objectSpread({}, req || {}), {}, {
          cause: `The request 'method' must be a non-empty string.`
        })
      });
    }
    next(done => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      log.error(`Ws-Embed - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}

/**
 * Logs a stream disconnection error. Emits an 'error' if given an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param log - The logging API to use.
 * @param remoteLabel - The label of the disconnected stream.
 * @param error - The associated error to log.
 * @param emitter - The logging API to use.
 */
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Web3Auth: Lost connection to "${remoteLabel}".`;
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += `\n${error.stack}`;
  }
  log.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
const EMITTED_NOTIFICATIONS = ["eth_subscription" // per eth-json-rpc-filters/subscriptionManager
];
const signerHost = (web3AuthNetwork = WEB3AUTH_NETWORK.SAPPHIRE_MAINNET) => {
  return SIGNER_MAP[web3AuthNetwork];
};
const fetchProjectConfig = async ({
  clientId,
  web3AuthNetwork,
  authBuildEnv
}) => {
  const url = new URL(`${signerHost(web3AuthNetwork)}/api/v2/configuration`);
  url.searchParams.append("project_id", clientId);
  url.searchParams.append("network", web3AuthNetwork);
  if (authBuildEnv) url.searchParams.append("build_env", authBuildEnv);
  const res = await get(url.href);
  return res;
};

export { EMITTED_NOTIFICATIONS, createErrorMiddleware, fetchProjectConfig, logStreamDisconnectWarning, signerHost };
