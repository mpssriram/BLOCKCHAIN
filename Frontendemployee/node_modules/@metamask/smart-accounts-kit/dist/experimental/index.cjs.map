{"version":3,"sources":["/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/experimental/index.cjs","../../src/experimental/delegationStorage.ts"],"names":[],"mappings":"AAAA;AACE;AACF,yDAA8B;AAC9B;AACA;ACJA,4BAAgC;AA6CzB,IAAM,wBAAA,EAAN,MAA8B;AAAA,EACnC,CAAA,iBAAA,EAAoB,QAAA;AAAA,EAEpB,CAAA,MAAA;AAAA,EAEA,CAAA,OAAA;AAAA,EAEA,CAAA,MAAA;AAAA,EAEA,WAAA,CAAY,MAAA,EAAiC;AAC3C,IAAA,MAAM,EAAE,OAAO,EAAA,EAAI,MAAA,CAAO,WAAA;AAE1B,IAAA,GAAA,CAAI,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,CAAA,gBAAiB,CAAA,EAAG;AAC3C,MAAA,IAAA,CAAK,CAAA,OAAA,EAAU,MAAA;AAAA,IACjB,EAAA,KAAO;AACL,MAAA,MAAM,UAAA,EAAY,MAAA,CAAO,QAAA,CAAS,GAAG,EAAA,EAAI,GAAA,EAAK,GAAA;AAC9C,MAAA,IAAA,CAAK,CAAA,OAAA,EAAU,CAAA,EAAA;AACjB,IAAA;AACgB,IAAA;AACD,IAAA;AACjB,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAamB,EAAA;AACN,IAAA;AACK,MAAA;AACE,IAAA;AACT,MAAA;AACT,IAAA;AACU,IAAA;AACR,MAAA;AACF,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWM,EAAA;AAGE,IAAA;AAKW,IAAA;AACA,MAAA;AACf,MAAA;AACU,QAAA;AACC,QAAA;AACP,UAAA;AACA,UAAA;AACF,QAAA;AACF,MAAA;AACF,IAAA;AAEM,IAAA;AAES,IAAA;AACH,MAAA;AACR,QAAA;AACF,MAAA;AACF,IAAA;AAEO,IAAA;AACT,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYM,EAAA;AAIa,IAAA;AACA,MAAA;AACf,MAAA;AACU,QAAA;AACC,QAAA;AACP,UAAA;AACA,UAAA;AACF,QAAA;AACF,MAAA;AACF,IAAA;AAEM,IAAA;AAES,IAAA;AACG,MAAA;AAClB,IAAA;AAEO,IAAA;AACT,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQM,EAAA;AACY,IAAA;AACE,MAAA;AAClB,IAAA;AAEM,IAAA;AAEY,IAAA;AAChB,MAAA;AACK,QAAA;AACQ,QAAA;AACb,MAAA;AAEE,MAAA;AAGF,MAAA;AACF,IAAA;AAEiB,IAAA;AACP,MAAA;AACC,MAAA;AACP,QAAA;AACA,QAAA;AACA,QAAA;AACF,MAAA;AACA,MAAA;AACD,IAAA;AAEK,IAAA;AAGS,IAAA;AACG,MAAA;AAClB,IAAA;AAEiB,IAAA;AACT,MAAA;AACJ,QAAA;AACF,MAAA;AACF,IAAA;AAEO,IAAA;AACT,EAAA;AACF;ADzEsB;AACA;AACA","file":"/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/experimental/index.cjs","sourcesContent":[null,"import { type Hex, toHex } from 'viem';\n\nimport { getDelegationHashOffchain } from '../delegation';\nimport type { Delegation } from '../types';\n\ntype ErrorResponse = {\n  error: string;\n  data?: any;\n};\n\nexport type APIStoreDelegationResponse = {\n  delegationHash: Hex;\n};\n\n/**\n * Represents the allowed filters when querying the data store for delegations.\n */\nexport enum DelegationStoreFilter {\n  Given = 'GIVEN',\n  Received = 'RECEIVED',\n  All = 'ALL',\n}\n\n/**\n * Public Delegation Storage Service environments. To be used in the\n * DeleGationStorageService config.\n */\nexport const DelegationStorageEnvironment: {\n  [K in 'dev' | 'prod']: Environment;\n} = {\n  dev: { apiUrl: 'https://passkeys.dev-api.cx.metamask.io' },\n  prod: { apiUrl: 'https://passkeys.api.cx.metamask.io' },\n};\n\nexport type Environment = {\n  apiUrl: string;\n};\n\nexport type DelegationStorageConfig = {\n  apiKey: string;\n  apiKeyId: string;\n  environment: Environment;\n  fetcher?: typeof fetch;\n};\n\nexport class DelegationStorageClient {\n  #apiVersionPrefix = 'api/v0';\n\n  #config: DelegationStorageConfig;\n\n  #fetcher: typeof fetch;\n\n  #apiUrl: string;\n\n  constructor(config: DelegationStorageConfig) {\n    const { apiUrl } = config.environment;\n\n    if (apiUrl.endsWith(this.#apiVersionPrefix)) {\n      this.#apiUrl = apiUrl;\n    } else {\n      const separator = apiUrl.endsWith('/') ? '' : '/';\n      this.#apiUrl = `${apiUrl}${separator}${this.#apiVersionPrefix}`;\n    }\n    this.#fetcher = this.#initializeFetcher(config);\n    this.#config = config;\n  }\n\n  /**\n   * Initializes the fetch function for HTTP requests.\n   *\n   * - Uses `config.fetcher` if provided.\n   * - Falls back to global `fetch` if available.\n   * - Throws an error if no fetch function is available.\n   *\n   * @param config - Configuration object that may include a custom fetch function.\n   * @returns The fetch function to be used for HTTP requests.\n   * @throws Error if no fetch function is available in the environment.\n   */\n  #initializeFetcher(config: DelegationStorageConfig): typeof fetch {\n    if (config.fetcher) {\n      return config.fetcher;\n    } else if (typeof globalThis?.fetch === 'function') {\n      return globalThis.fetch.bind(globalThis);\n    }\n    throw new Error(\n      'Fetch API is not available in this environment. Please provide a fetch function in the config.',\n    );\n  }\n\n  /**\n   * Fetches the delegation chain from the Delegation Storage Service, ending with\n   * the specified leaf delegation.\n   *\n   * @param leafDelegationOrDelegationHash - The leaf delegation, or the hash\n   * of the leaf delegation.\n   * @returns A promise that resolves to the delegation chain - empty array if the delegation\n   * is not found.\n   */\n  async getDelegationChain(\n    leafDelegationOrDelegationHash: Hex | Delegation,\n  ): Promise<Delegation[]> {\n    const leafDelegationHash =\n      typeof leafDelegationOrDelegationHash === 'string'\n        ? leafDelegationOrDelegationHash\n        : getDelegationHashOffchain(leafDelegationOrDelegationHash);\n\n    const response = await this.#fetcher(\n      `${this.#apiUrl}/delegation/chain/${leafDelegationHash}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.#config.apiKey}`,\n          'x-api-key-id': this.#config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(\n        `Failed to fetch delegation chain: ${responseData.error}`,\n      );\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Fetches the delegations from the Delegation Storage Service, either `Received`\n   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults\n   * to `Received`.\n   *\n   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.\n   * @param filterMode - The DelegationStoreFilter mode - defaults to Received.\n   * @returns A promise that resolves to the list of delegations received by the deleGatorAddress,\n   * empty array if the delegations are not found.\n   */\n  async fetchDelegations(\n    deleGatorAddress: Hex,\n    filterMode = DelegationStoreFilter.Received,\n  ): Promise<Delegation[]> {\n    const response = await this.#fetcher(\n      `${this.#apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.#config.apiKey}`,\n          'x-api-key-id': this.#config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(`Failed to fetch delegations: ${responseData.error}`);\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Stores the specified delegation in the Delegation Storage Service.\n   *\n   * @param delegation - The delegation to store.\n   * @returns A promise that resolves to the delegation hash indicating successful storage.\n   */\n  async storeDelegation(delegation: Delegation): Promise<Hex> {\n    if (!delegation.signature || delegation.signature === '0x') {\n      throw new Error('Delegation must be signed to be stored');\n    }\n\n    const delegationHash = getDelegationHashOffchain(delegation);\n\n    const body = JSON.stringify(\n      {\n        ...delegation,\n        metadata: [],\n      },\n      (_, value: any) =>\n        typeof value === 'bigint' || typeof value === 'number'\n          ? toHex(value)\n          : value,\n      2,\n    );\n\n    const response = await this.#fetcher(`${this.#apiUrl}/delegation/store`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this.#config.apiKey}`,\n        'x-api-key-id': this.#config.apiKeyId,\n        'Content-Type': 'application/json',\n      },\n      body,\n    });\n\n    const responseData: APIStoreDelegationResponse | ErrorResponse =\n      await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(responseData.error);\n    }\n\n    if (responseData.delegationHash !== delegationHash) {\n      throw Error(\n        'Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation',\n      );\n    }\n\n    return responseData.delegationHash;\n  }\n}\n"]}