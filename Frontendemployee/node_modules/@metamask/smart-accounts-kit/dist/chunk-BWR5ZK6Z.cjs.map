{"version":3,"sources":["/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/chunk-BWR5ZK6Z.cjs","../src/write.ts","../src/smartAccountsEnvironment.ts","../src/userOp.ts"],"names":["SimpleFactory","DelegationManager"],"mappings":"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","file":"/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/chunk-BWR5ZK6Z.cjs","sourcesContent":[null,"import { SimpleFactory, DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport { encodePermissionContexts } from './delegation';\nimport type { ExecutionStruct, ExecutionMode } from './executions';\nimport { encodeExecutionCalldatas } from './executions';\nimport type { Delegation, ContractMetaData, Redemption } from './types';\n\n/**\n * Deploys a contract using the SimpleFactory contract.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for simulation.\n * @param simpleFactoryAddress - The address of the SimpleFactory contract.\n * @param creationCode - The creation code for the contract to deploy.\n * @param salt - The salt to use for deterministic deployment.\n * @returns The transaction hash of the deployment.\n */\nexport const deployWithSimpleFactory = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  simpleFactoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: simpleFactoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Redeems a delegation to execute the provided executions.\n * @param walletClient - The wallet client to use for redemption.\n * @param publicClient - The public client to use for simulation.\n * @param delegationManagerAddress - The address of the DelegationManager contract.\n * @param redemptions - The redemptions to execute, containing permission contexts, executions, and modes.\n * @returns The transaction hash of the redemption.\n */\nexport const redeemDelegations = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  delegationManagerAddress: Address,\n  redemptions: Redemption[],\n) => {\n  if (redemptions.length === 0) {\n    throw new Error('RedeemDelegations invalid zero redemptions');\n  }\n\n  const permissionContexts: Delegation[][] = [];\n  const executionsBatch: ExecutionStruct[][] = [];\n  const executionModes: ExecutionMode[] = [];\n\n  redemptions.forEach((redemption) => {\n    permissionContexts.push(redemption.permissionContext);\n    executionsBatch.push(redemption.executions);\n    executionModes.push(redemption.mode);\n  });\n\n  const encodedPermissionContexts =\n    encodePermissionContexts(permissionContexts);\n  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);\n\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: delegationManagerAddress,\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [encodedPermissionContexts, executionModes, executionCalldatas],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Deploys a contract to the blockchain.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for transaction receipt.\n * @param chain - The chain to deploy on.\n * @param contractMetadata - The metadata of the contract to deploy.\n * @param contractMetadata.bytecode - The bytecode of the contract to deploy.\n * @param contractMetadata.abi - The ABI of the contract to deploy.\n * @param args - The constructor arguments for the contract.\n * @returns An object containing the deployed contract address, transaction hash, and receipt.\n */\nexport async function deployContract(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  { bytecode, abi }: ContractMetaData,\n  args: any[] = [],\n) {\n  if (!walletClient.account) {\n    throw new Error('Wallet client account is required');\n  }\n\n  const hash = await walletClient.deployContract({\n    abi,\n    bytecode,\n    args,\n    account: walletClient.account,\n    chain,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  if (!receipt.contractAddress) {\n    throw new Error('No contract address in receipt');\n  }\n\n  return { address: receipt.contractAddress, hash, receipt };\n}\n","import {\n  EntryPoint,\n  SimpleFactory,\n  DelegationManager,\n  MultiSigDeleGator,\n  HybridDeleGator,\n  EIP7702StatelessDeleGator,\n  SCL_RIP7212,\n  AllowedTargetsEnforcer,\n  AllowedMethodsEnforcer,\n  DeployedEnforcer,\n  TimestampEnforcer,\n  NonceEnforcer,\n  AllowedCalldataEnforcer,\n  BlockNumberEnforcer,\n  LimitedCallsEnforcer,\n  ERC20BalanceChangeEnforcer,\n  ERC20StreamingEnforcer,\n  IdEnforcer,\n  ERC20TransferAmountEnforcer,\n  ValueLteEnforcer,\n  NativeTokenTransferAmountEnforcer,\n  NativeBalanceChangeEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenPaymentEnforcer,\n  RedeemerEnforcer,\n  ArgsEqualityCheckEnforcer,\n  ERC721BalanceChangeEnforcer,\n  ERC721TransferEnforcer,\n  ERC1155BalanceChangeEnforcer,\n  OwnershipTransferEnforcer,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  ExactCalldataBatchEnforcer,\n  ExactCalldataEnforcer,\n  ExactExecutionEnforcer,\n  ExactExecutionBatchEnforcer,\n  MultiTokenPeriodEnforcer,\n} from '@metamask/delegation-abis';\nimport { DELEGATOR_CONTRACTS } from '@metamask/delegation-deployments';\nimport type { Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport type { ContractMetaData, SmartAccountsEnvironment } from './types';\nimport { deployContract } from './write';\n\ntype SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';\nexport const PREFERRED_VERSION: SupportedVersion = '1.3.0';\n\nconst contractOverrideMap: Map<string, SmartAccountsEnvironment> = new Map();\n\nconst getContractOverrideKey = (chainId: number, version: SupportedVersion) =>\n  `${version}:${chainId}`;\n\n/**\n * Overrides the default environment for a specific chain and version.\n * @param chainId - The chain ID to override.\n * @param version - The version of the environment to override.\n * @param environment - The environment to use as override.\n */\nexport function overrideDeployedEnvironment(\n  chainId: number,\n  version: SupportedVersion,\n  environment: SmartAccountsEnvironment,\n) {\n  contractOverrideMap.set(\n    getContractOverrideKey(chainId, version),\n    environment,\n  );\n}\n\n/**\n * Gets the SmartAccountsEnvironment for the specified chain and version.\n * @param chainId - The chain ID to get the environment for.\n * @param version - The version of the environment to get.\n * @returns The SmartAccountsEnvironment.\n */\nexport function getSmartAccountsEnvironment(\n  chainId: number,\n  version: SupportedVersion = PREFERRED_VERSION,\n): SmartAccountsEnvironment {\n  const overrideKey = getContractOverrideKey(chainId, version);\n\n  const overriddenContracts = contractOverrideMap.get(overrideKey);\n  if (overriddenContracts) {\n    return overriddenContracts;\n  }\n\n  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];\n  if (!contracts) {\n    throw new Error(\n      `No contracts found for version ${version} chain ${chainId}`,\n    );\n  }\n  return getSmartAccountsEnvironmentV1(contracts);\n}\n\n/**\n * Creates a SmartAccountsEnvironment from contract addresses.\n * @param contracts - The contract addresses to create the environment from.\n * @returns The created SmartAccountsEnvironment.\n */\nexport function getSmartAccountsEnvironmentV1(contracts: {\n  [contract: string]: Hex;\n}) {\n  return {\n    DelegationManager: contracts.DelegationManager,\n    EntryPoint: contracts.EntryPoint,\n    SimpleFactory: contracts.SimpleFactory,\n    implementations: {\n      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,\n      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,\n      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl,\n    },\n    caveatEnforcers: {\n      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,\n      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,\n      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,\n      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,\n      BlockNumberEnforcer: contracts.BlockNumberEnforcer,\n      DeployedEnforcer: contracts.DeployedEnforcer,\n      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,\n      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,\n      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,\n      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,\n      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,\n      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,\n      IdEnforcer: contracts.IdEnforcer,\n      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,\n      NonceEnforcer: contracts.NonceEnforcer,\n      TimestampEnforcer: contracts.TimestampEnforcer,\n      ValueLteEnforcer: contracts.ValueLteEnforcer,\n      NativeTokenTransferAmountEnforcer:\n        contracts.NativeTokenTransferAmountEnforcer,\n      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,\n      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,\n      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,\n      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,\n      RedeemerEnforcer: contracts.RedeemerEnforcer,\n      SpecificActionERC20TransferBatchEnforcer:\n        contracts.SpecificActionERC20TransferBatchEnforcer,\n      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,\n      NativeTokenPeriodTransferEnforcer:\n        contracts.NativeTokenPeriodTransferEnforcer,\n      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,\n      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,\n      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,\n      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,\n      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer,\n    },\n  } as SmartAccountsEnvironment;\n}\n\nexport type DeployedContract = {\n  name: string;\n  address: string;\n};\n\n/**\n * Deploys the contracts needed for the Delegation Framework and MetaMask SCA to be functional as well as all Caveat Enforcers.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for deployment.\n * @param chain - The chain to deploy to.\n * @param deployedContracts - Optional map of already deployed contracts.\n * @returns A promise that resolves to the SmartAccountsEnvironment.\n */\nexport async function deploySmartAccountsEnvironment(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  deployedContracts: { [contract: string]: Hex } = {},\n) {\n  const deployContractCurried = async (\n    name: string,\n    contract: ContractMetaData,\n    params: any[] = [],\n  ) => {\n    const existingAddress = deployedContracts[name];\n    if (existingAddress) {\n      return {\n        address: existingAddress,\n        name,\n      };\n    }\n\n    const deployedContract = await deployContract(\n      walletClient,\n      publicClient,\n      chain,\n      contract,\n      params,\n    );\n\n    const newDeployedContracts = { ...deployedContracts };\n    newDeployedContracts[name] = deployedContract.address;\n    Object.assign(deployedContracts, newDeployedContracts);\n\n    return { ...deployedContract, name };\n  };\n\n  // Deploy v1.3.0 DeleGator contracts\n  // - deploy standalone contracts\n  const standaloneContracts = {\n    SimpleFactory,\n    AllowedCalldataEnforcer,\n    AllowedTargetsEnforcer,\n    AllowedMethodsEnforcer,\n    ArgsEqualityCheckEnforcer,\n    DeployedEnforcer,\n    TimestampEnforcer,\n    BlockNumberEnforcer,\n    LimitedCallsEnforcer,\n    ERC20BalanceChangeEnforcer,\n    ERC20TransferAmountEnforcer,\n    ERC20StreamingEnforcer,\n    ERC721BalanceChangeEnforcer,\n    ERC721TransferEnforcer,\n    ERC1155BalanceChangeEnforcer,\n    IdEnforcer,\n    NonceEnforcer,\n    ValueLteEnforcer,\n    NativeTokenTransferAmountEnforcer,\n    NativeBalanceChangeEnforcer,\n    NativeTokenStreamingEnforcer,\n    OwnershipTransferEnforcer,\n    RedeemerEnforcer,\n    SpecificActionERC20TransferBatchEnforcer,\n    ERC20PeriodTransferEnforcer,\n    NativeTokenPeriodTransferEnforcer,\n    ExactCalldataBatchEnforcer,\n    ExactCalldataEnforcer,\n    ExactExecutionEnforcer,\n    ExactExecutionBatchEnforcer,\n    MultiTokenPeriodEnforcer,\n  };\n  for (const [name, contract] of Object.entries(standaloneContracts)) {\n    await deployContractCurried(name, contract);\n  }\n\n  // - deploy dependencies\n  const delegationManager = await deployContractCurried(\n    'DelegationManager',\n    DelegationManager,\n    [walletClient.account?.address],\n  );\n\n  // - NativeTokenPaymentEnforcer DelegationManager and ArgsEqualityCheckEnforcer as constructor args\n  await deployContractCurried(\n    'NativeTokenPaymentEnforcer',\n    NativeTokenPaymentEnforcer,\n    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer],\n  );\n\n  const entryPoint = await deployContractCurried('EntryPoint', EntryPoint);\n\n  // This is a hack to work around the SCL_RIP7212 being deployed as a library.\n  // Forge handles this gracefully, but in the tests we need to manually link\n  // the library.\n  // We don't use the curried function here because we don't need it added to\n  // the environment.\n  const { address: sclRIP7212 } = await deployContract(\n    walletClient,\n    publicClient,\n    chain,\n    SCL_RIP7212,\n    [],\n  );\n\n  // replace linked library address in bytecode https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking\n  const hybridDeleGatorWithLinkedLibrary = {\n    ...HybridDeleGator,\n    bytecode: HybridDeleGator.bytecode.replace(\n      /__\\$b8f96b288d4d0429e38b8ed50fd423070f\\$__/gu,\n      sclRIP7212.slice(2),\n    ) as Hex,\n  };\n\n  // - deploy DeleGator implementations\n  await deployContractCurried(\n    'HybridDeleGatorImpl',\n    hybridDeleGatorWithLinkedLibrary,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  await deployContractCurried('MultiSigDeleGatorImpl', MultiSigDeleGator, [\n    delegationManager.address,\n    entryPoint.address,\n  ]);\n\n  await deployContractCurried(\n    'EIP7702StatelessDeleGatorImpl',\n    EIP7702StatelessDeleGator,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  // Format deployments\n  return getSmartAccountsEnvironmentV1(deployedContracts);\n}\n","import { concat, encodeAbiParameters, keccak256, pad, toHex } from 'viem';\nimport type { Address, Hex, TypedData } from 'viem';\nimport { toPackedUserOperation } from 'viem/account-abstraction';\nimport { signTypedData } from 'viem/accounts';\n\nimport type { OptionalUserOpProps, PackedUserOperationStruct } from './types';\n\n// v7 off-chain user operation, hexlified incoming data from rpc call\nexport type UserOperationV07Hexlify = {\n  sender: Hex;\n  nonce: Hex;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: Hex;\n  paymasterPostOpGasLimit?: Hex;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n// v7 off-chain user operation with BigInt fields\nexport type UserOperationV07 = {\n  sender: Hex;\n  nonce: bigint;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n/**\n * Creates a raw user operation data structure.\n * @param sender - The smart account taking some action.\n * @param nonce - A nonce, ideally fetched from the Entry Point.\n * @param callData - Calldata to invoke on some contract.\n * @param signature - The signature for the user operation.\n * @param options - Optional properties for the user operation.\n * @returns The created raw user operation data structure.\n */\nexport const createRawUserOp = (\n  sender: Hex,\n  nonce: bigint,\n  callData: Hex,\n  signature: Hex = '0x',\n  options?: OptionalUserOpProps,\n): UserOperationV07 => ({\n  sender,\n  nonce,\n  callData,\n  factory: options?.factory,\n  factoryData: options?.factoryData,\n  callGasLimit: options?.callGasLimit ?? 0n,\n  verificationGasLimit: options?.verificationGasLimit ?? 0n,\n  preVerificationGas: options?.preVerificationGas ?? 0n,\n  maxFeePerGas: options?.maxFeePerGas ?? 0n,\n  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,\n  paymaster: options?.paymaster,\n  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,\n  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,\n  paymasterData: options?.paymasterData,\n  signature,\n});\n\n// //////////////////////////////////////////////////////////////////////////////////////\n\n// TODO: These userOp functions are duplicated in ./apps/ew-client/src/utils/userOpBuilder.ts. We should move them to a shared location along with test(./apps/ew-client/test/UserOpBuilder.test.ts) to avoid duplication\n/**\n * Generates a salt value for address derivation.\n * @param salt - Optional salt value.\n * @returns The chosen salt value.\n */\nexport const getSalt = (salt?: Hex): Hex => {\n  return salt ?? '0x0';\n};\n\nexport const getPaymasterAndData = (userOp: UserOperationV07): Hex => {\n  let paymasterAndData: Hex;\n  if (userOp.paymaster) {\n    paymasterAndData = concat([\n      userOp.paymaster,\n      pad(toHex(userOp.paymasterVerificationGasLimit ?? 0n), {\n        size: 16,\n      }),\n      pad(toHex(userOp.paymasterPostOpGasLimit ?? 0n), {\n        size: 16,\n      }),\n      userOp.paymasterData ?? '0x',\n    ]);\n  } else {\n    paymasterAndData = '0x';\n  }\n\n  return paymasterAndData;\n};\n\nexport const getInitCode = (userOp: UserOperationV07): Hex => {\n  return userOp.factory\n    ? concat([userOp.factory, userOp.factoryData ?? ('0x' as Hex)])\n    : '0x';\n};\n\nexport const getAccountGasLimits = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(userOp.callGasLimit), { size: 16 }),\n  ]);\n};\n\nexport const getGasFees = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(userOp.maxFeePerGas), { size: 16 }),\n  ]);\n};\n\n/**\n * Packs a user operation into a `PackedUserOperationStruct` object.\n *\n * @param userOp - The user operation to pack.\n * @returns The packed user operation.\n */\nexport const packUserOp = (\n  userOp: UserOperationV07,\n): PackedUserOperationStruct => {\n  const packedOp = {\n    sender: userOp.sender,\n    nonce: BigInt(userOp.nonce),\n    initCode: getInitCode(userOp),\n    callData: userOp.callData,\n    accountGasLimits: getAccountGasLimits(userOp),\n    preVerificationGas: BigInt(userOp.preVerificationGas),\n    gasFees: getGasFees(userOp),\n    paymasterAndData: getPaymasterAndData(userOp),\n    signature: userOp.signature,\n  };\n\n  return packedOp;\n};\n\n/**\n * Calculates the user operation hash for a given packed user operation.\n * @param packedOp - The packed user operation.\n * @param entryPoint - The entry point address.\n * @param chainId - The chain ID.\n * @returns The user operation hash.\n */\nexport const createUserOpHashV07 = (\n  packedOp: PackedUserOperationStruct,\n  entryPoint: Hex,\n  chainId: bigint,\n) => {\n  const hash = keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'sender',\n          type: 'address',\n        },\n        {\n          name: 'nonce',\n          type: 'uint256',\n        },\n        {\n          name: 'initCodeHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'callDataHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'accountGasLimits',\n          type: 'bytes32',\n        },\n        {\n          name: 'preVerificationGas',\n          type: 'uint256',\n        },\n        {\n          name: 'gasFees',\n          type: 'bytes32',\n        },\n        {\n          name: 'paymasterAndDataHash',\n          type: 'bytes32',\n        },\n      ],\n      [\n        packedOp.sender,\n        packedOp.nonce,\n        keccak256(packedOp.initCode),\n        keccak256(packedOp.callData),\n        packedOp.accountGasLimits,\n        packedOp.preVerificationGas,\n        packedOp.gasFees,\n        keccak256(packedOp.paymasterAndData),\n      ],\n    ),\n  );\n\n  return keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'userOpHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'entryPointAddress',\n          type: 'address',\n        },\n        {\n          name: 'chainId',\n          type: 'uint256',\n        },\n      ],\n      [hash, entryPoint, chainId],\n    ),\n  );\n};\n\nexport const SIGNABLE_USER_OP_TYPED_DATA: TypedData = {\n  PackedUserOperation: [\n    { name: 'sender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'initCode', type: 'bytes' },\n    { name: 'callData', type: 'bytes' },\n    { name: 'accountGasLimits', type: 'bytes32' },\n    { name: 'preVerificationGas', type: 'uint256' },\n    { name: 'gasFees', type: 'bytes32' },\n    { name: 'paymasterAndData', type: 'bytes' },\n    { name: 'entryPoint', type: 'address' },\n  ],\n} as const;\n\n/**\n * Prepares typed data for user operation signing.\n * This is an internal helper function that's not exposed in the public API.\n *\n * @param params - The parameters for preparing the typed data.\n * @param params.userOperation - The user operation to prepare for signing.\n * @param params.entryPoint - The entry point contract address.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @returns The prepared typed data for signing.\n */\nexport const prepareSignUserOperationTypedData = ({\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  address: Address;\n  version?: string;\n}) => {\n  const packedUserOp = toPackedUserOperation({\n    ...userOperation,\n    signature: '0x',\n  });\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: address,\n    },\n    types: SIGNABLE_USER_OP_TYPED_DATA,\n    primaryType: 'PackedUserOperation' as const,\n    message: { ...packedUserOp, entryPoint: entryPoint.address },\n  };\n};\n\n/**\n * Signs a user operation using a private key.\n * @param params - The parameters for signing the user operation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.userOperation - The user operation to sign.\n * @param params.entryPoint - The entry point contract address.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @returns The signature of the user operation.\n */\nexport const signUserOperation = async ({\n  privateKey,\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  privateKey: Hex;\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  address: Address;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  version?: string;\n}) => {\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n"]}