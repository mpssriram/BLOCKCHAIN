'use strict';

var util = require('@ethereumjs/util');
var auth = require('@web3auth/auth');
var ethers = require('ethers');
var uuid = require('uuid');
var eip7702Utils = require('../Eip7702/eip7702Utils.js');
var eip5792Types = require('../utils/eip5792Types.js');

/**
 * Generates a unique batch ID for EIP-5792 calls.
 * @returns A unique hex string batch ID.
 */
function generateBatchId() {
  const idString = uuid.v4();
  const idBytes = new Uint8Array(uuid.parse(idString));
  const hexString = Array.from(idBytes).map(byte => byte.toString(16).padStart(2, "0")).join("");
  return `0x${hexString}`;
}
/**
 * Validates a single call in the batch.
 * @param call - The call to validate.
 * @param index - The index of the call in the batch (for error messages).
 */
function validateCall(call, index) {
  // Validate 'to' address
  if (!call.to || !ethers.isHexString(call.to) || !util.isValidAddress(call.to)) {
    throw auth.rpcErrors.invalidParams(`Invalid 'to' address in call at index ${index}`);
  }
  // Validate 'value' if present
  if (call.value !== undefined) {
    if (!ethers.isHexString(call.value)) {
      throw auth.rpcErrors.invalidParams(`Invalid 'value' in call at index ${index}: must be a valid non-negative hex string`);
    }
  }
  // Validate 'data' if present
  if (call.data !== undefined) {
    if (!ethers.isHexString(call.data)) {
      throw auth.rpcErrors.invalidParams(`Invalid 'data' in call at index ${index}: must be a valid hex string`);
    }
  }
}
/**
 * Validates the parameters for wallet_sendCalls (EIP-5792).
 * @param sendCallsParams - The parameters to validate.
 */
function validateSendCallsParams(sendCallsParams) {
  // Basic structure validation
  if (!sendCallsParams) {
    throw auth.rpcErrors.invalidParams("Missing send calls parameters");
  }
  // Validate version format
  if (!sendCallsParams.version || !eip5792Types.SUPPORTED_EIP_5792_VERSIONS.includes(sendCallsParams.version)) {
    throw auth.rpcErrors.invalidParams(`Invalid version: expected one of ${eip5792Types.SUPPORTED_EIP_5792_VERSIONS.join(", ")}, got "${sendCallsParams.version || "undefined"}"`);
  }
  // Validate chainId format
  if (!sendCallsParams.chainId || !ethers.isHexString(sendCallsParams.chainId)) {
    throw auth.rpcErrors.invalidParams("Invalid chainId: must be a valid hex string");
  }
  // Validate 'from' address
  if (!sendCallsParams.from) {
    throw auth.rpcErrors.invalidParams("Missing 'from' address");
  }
  if (!ethers.isHexString(sendCallsParams.from) || !util.isValidAddress(sendCallsParams.from)) {
    throw auth.rpcErrors.invalidParams("Invalid 'from' address: must be a valid hex address");
  }
  // Validate calls array
  if (!Array.isArray(sendCallsParams.calls) || sendCallsParams.calls.length === 0) {
    throw auth.rpcErrors.invalidParams("Invalid calls: must be a non-empty array");
  }
  // Validate each call
  sendCallsParams.calls.forEach((call, index) => {
    validateCall(call, index);
  });
}
async function processMultipleTransactions({
  from,
  transactions,
  request,
  chainId,
  getEthCode,
  processTransactionBatch
}) {
  // check if the account is upgraded with EIP-7702 for the given chain
  const {
    isSupported,
    upgradeContractAddress,
    delegationAddress
  } = await eip7702Utils.getIsEip7702UpgradeSupported(from, chainId, getEthCode);
  if (!isSupported) {
    throw auth.rpcErrors.methodNotSupported(`EIP-7702 upgrade is not supported for the given chain, ${chainId}`);
  }
  const hasAccountAlreadyUpgraded = Boolean(delegationAddress);
  const batchRequest = {
    batchId: generateBatchId(),
    transactions,
    eip7702UpgradeContractAddress: upgradeContractAddress,
    requiredEip7702Upgrade: !hasAccountAlreadyUpgraded
  };
  // prepare batch transactions
  return processTransactionBatch(batchRequest, request);
}
async function processSingleTransaction({
  transactions,
  request,
  processTransactionBatch
}) {
  const batchRequestWithSingleCall = {
    batchId: generateBatchId(),
    transactions
  };
  return processTransactionBatch(batchRequestWithSingleCall, request);
}
/**
 * Handler for wallet_sendCalls (EIP-5792).
 * Sends a batch of calls for an EIP-7702 upgraded account.
 *
 * @param request - The JRPC request with send calls parameters.
 * @param getEthCode - Function to get the code at an address.
 * @param context - Context containing required functions.
 * @returns The batch ID.
 */
async function walletSendCalls(request, getEthCode, context) {
  const {
    method,
    params
  } = request;
  if (method !== eip5792Types.EIP_5792_METHODS.WALLET_SEND_CALLS) {
    return;
  }
  const sendCallsParams = Array.isArray(params) ? params[0] : params;
  validateSendCallsParams(sendCallsParams);
  const {
    chainId,
    from,
    calls
  } = sendCallsParams;
  const transactions = calls.map(call => ({
    params: call
  }));
  const isBatchCalls = Object.keys(transactions).length > 1;
  if (!isBatchCalls) {
    return processSingleTransaction({
      transactions,
      request,
      processTransactionBatch: context.processTransactionBatch
    });
  }
  return processMultipleTransactions({
    from: from,
    transactions,
    request,
    chainId,
    getEthCode,
    processTransactionBatch: context.processTransactionBatch
  });
}

exports.generateBatchId = generateBatchId;
exports.processMultipleTransactions = processMultipleTransactions;
exports.processSingleTransaction = processSingleTransaction;
exports.validateSendCallsParams = validateSendCallsParams;
exports.walletSendCalls = walletSendCalls;
