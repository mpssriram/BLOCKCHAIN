'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var constants = require('@toruslabs/constants');
var httpHelpers = require('@toruslabs/http-helpers');
var auth = require('@web3auth/auth');
var loglevel = require('./loglevel.js');

// utility functions
/**
 * json-rpc-engine middleware that logs RPC errors and and validates req.method.
 *
 * @param log - The logging API to use.
 * @returns  json-rpc-engine middleware function
 */
function createErrorMiddleware() {
  return (req, res, next) => {
    // json-rpc-engine will terminate the request when it notices this error
    if (typeof req.method !== "string" || !req.method) {
      res.error = auth.rpcErrors.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: _objectSpread(_objectSpread({}, req || {}), {}, {
          cause: `The request 'method' must be a non-empty string.`
        })
      });
    }
    next(done => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      loglevel.error(`Ws-Embed - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}
/**
 * Logs a stream disconnection error. Emits an 'error' if given an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param log - The logging API to use.
 * @param remoteLabel - The label of the disconnected stream.
 * @param error - The associated error to log.
 * @param emitter - The logging API to use.
 */
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Web3Auth: Lost connection to "${remoteLabel}".`;
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += `\n${error.stack}`;
  }
  loglevel.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
const EMITTED_NOTIFICATIONS = ["eth_subscription" // per eth-json-rpc-filters/subscriptionManager
];
const signerHost = (web3AuthNetwork = auth.WEB3AUTH_NETWORK.SAPPHIRE_MAINNET) => {
  return constants.SIGNER_MAP[web3AuthNetwork];
};
const fetchProjectConfig = async ({
  clientId,
  web3AuthNetwork,
  authBuildEnv
}) => {
  const url = new URL(`${signerHost(web3AuthNetwork)}/api/v2/configuration`);
  url.searchParams.append("project_id", clientId);
  url.searchParams.append("network", web3AuthNetwork);
  if (authBuildEnv) url.searchParams.append("build_env", authBuildEnv);
  const res = await httpHelpers.get(url.href);
  return res;
};

exports.EMITTED_NOTIFICATIONS = EMITTED_NOTIFICATIONS;
exports.createErrorMiddleware = createErrorMiddleware;
exports.fetchProjectConfig = fetchProjectConfig;
exports.logStreamDisconnectWarning = logStreamDisconnectWarning;
exports.signerHost = signerHost;
