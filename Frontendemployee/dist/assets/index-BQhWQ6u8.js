import{n as u,m,_ as c,o as v,q as E,r as w,s as o,t as d,u as f,W as a,v as N}from"./index-BRB0XtRz.js";class p extends m{constructor(e){super(e),c(this,"connectorNamespace",v.EIP155),c(this,"currentChainNamespace",E.EIP155),c(this,"type",w.EXTERNAL),c(this,"name",void 0),c(this,"isInjected",!0),c(this,"status",o.NOT_READY),c(this,"injectedProvider",null),this.name=e.name,this.injectedProvider=e.provider,this.icon=e.icon}get provider(){return this.status!==o.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(e){throw new Error("Not implemented")}async init(e){await super.init(e);const n=this.coreOptions.chains.find(i=>i.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:n}),this.status=o.READY,this.emit(d.READY,this.name);try{if(f.debug(`initializing ${this.name} injected connector`),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId,getIdentityToken:e.getIdentityToken})))throw this.rehydrated=!1,a.connectionError("Failed to rehydrate.")}catch(i){this.emit(d.REHYDRATION_ERROR,i)}}async connect({chainId:e,getIdentityToken:n}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw a.connectionError("Injected provider is not available");const i=this.coreOptions.chains.find(t=>t.chainId===e);if(!i)throw a.connectionError("Chain config is not available");this.status=o.CONNECTING,this.emit(d.CONNECTING,{connector:this.name});try{if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==i.chainId)try{await this.switchChain(i,!0)}catch{await this.addChain(i,!0),await this.switchChain(i,!0)}this.status=o.CONNECTED;const t=l=>{if(l.length===0){var h;this.disconnect(),(h=this.injectedProvider)!==null&&h!==void 0&&h.removeListener&&this.injectedProvider.removeListener("accountsChanged",t)}};this.injectedProvider.on("accountsChanged",t);let s;return this.emit(d.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider,identityTokenInfo:s}),n&&(s=await this.getIdentityToken()),this.injectedProvider}catch(t){throw this.status=o.READY,this.rehydrated||this.emit(d.ERRORED,t),this.rehydrated=!1,t instanceof N?t:a.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(e={cleanup:!1}){if(!this.injectedProvider)throw a.connectionError("Injected provider is not available");await super.disconnectSession(),typeof this.injectedProvider.removeAllListeners<"u"&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}e.cleanup?(this.status=o.NOT_READY,this.injectedProvider=null):this.status=o.READY,await super.disconnect()}async getUserInfo(){if(!this.canAuthorize)throw a.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e,n=!1){if(!this.injectedProvider)throw a.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorerUrl],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18},iconUrls:[e.logo]}]})}async switchChain(e,n=!1){if(!this.injectedProvider)throw a.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(e,n),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}async enableMFA(){throw new Error("Method Not implemented")}async manageMFA(){throw new Error("Method Not implemented")}}const y=r=>({coreOptions:e})=>new p({name:u(r.info.name),provider:r.provider,icon:r.info.icon,coreOptions:e});function C(r){if(typeof window>"u")return;const e=n=>r(n.detail);return window.addEventListener("eip6963:announceProvider",e),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",e)}function I(){const r=new Set;let e=[];const n=()=>C(t=>{e.some(({info:s})=>s.uuid===t.info.uuid)||(e=[...e,t],r.forEach(s=>s(e,{added:[t]})))});let i=n();return{_listeners(){return r},clear(){r.forEach(t=>t([],{removed:[...e]})),e=[]},destroy(){this.clear(),r.clear(),i==null||i()},findProvider({rdns:t}){return e.find(s=>s.info.rdns===t)},getProviders(){return e},reset(){this.clear(),i==null||i(),i=n()},subscribe(t,{emitImmediately:s}={}){return r.add(t),s&&t(e,{added:e}),()=>r.delete(t)}}}export{I as createMipd,y as injectedEvmConnector};
