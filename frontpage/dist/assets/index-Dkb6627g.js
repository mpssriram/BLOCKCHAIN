var hs=Object.defineProperty;var ps=(e,n,t)=>n in e?hs(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var $t=(e,n,t)=>ps(e,typeof n!="symbol"?n+"":n,t);import{aG as lr,ag as hr,aH as ys,aI as bn,aJ as En,aK as gs,aL as ws,W as Re,aM as Kn,s as Se,t as ke,S as Zt,aN as ms,aO as bs,aP as Es,aQ as vs,aR as xs,aS as Ss,D as As,aT as Ze,aU as Bt,aV as Ft,aW as Oe,aX as Bs,aY as vn,aZ as Is,as as pr,ak as fe,a_ as Rs,a0 as ks,a$ as ne,B as _s,J as Os,p as Ts,b0 as Yt,n as Us,_ as De,o as Ls,q as Cs,r as Ns,u as zs}from"./index-LQJmjVny.js";import{a as Fs,h as Ds,s as Ks}from"./hmac-ByT5zJZT.js";import{s as qn}from"./sha256-TxHcAcle.js";import{c as qs,a as Ms,b as nt}from"./solanaRpcMiddlewares-BV7DPW73.js";var Ps=lr();const Mn=hr(Ps);var Pn,Gt,Ht=0,Wt=0;function Vs(e,n,t){var r=n&&t||0,s=n||new Array(16);e=e||{};var o=e.node||Pn,i=e.clockseq!==void 0?e.clockseq:Gt;if(o==null||i==null){var f=e.random||(e.rng||ys)();o==null&&(o=Pn=[f[0]|1,f[1],f[2],f[3],f[4],f[5]]),i==null&&(i=Gt=(f[6]<<8|f[7])&16383)}var c=e.msecs!==void 0?e.msecs:Date.now(),h=e.nsecs!==void 0?e.nsecs:Wt+1,b=c-Ht+(h-Wt)/1e4;if(b<0&&e.clockseq===void 0&&(i=i+1&16383),(b<0||c>Ht)&&e.nsecs===void 0&&(h=0),h>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Ht=c,Wt=h,Gt=i,c+=122192928e5;var R=((c&268435455)*1e4+h)%4294967296;s[r++]=R>>>24&255,s[r++]=R>>>16&255,s[r++]=R>>>8&255,s[r++]=R&255;var g=c/4294967296*1e4&268435455;s[r++]=g>>>8&255,s[r++]=g&255,s[r++]=g>>>24&15|16,s[r++]=g>>>16&255,s[r++]=i>>>8|128,s[r++]=i&255;for(var E=0;E<6;++E)s[r+E]=o[E];return n||bn(s)}function yr(e){if(!En(e))throw TypeError("Invalid UUID");var n,t=new Uint8Array(16);return t[0]=(n=parseInt(e.slice(0,8),16))>>>24,t[1]=n>>>16&255,t[2]=n>>>8&255,t[3]=n&255,t[4]=(n=parseInt(e.slice(9,13),16))>>>8,t[5]=n&255,t[6]=(n=parseInt(e.slice(14,18),16))>>>8,t[7]=n&255,t[8]=(n=parseInt(e.slice(19,23),16))>>>8,t[9]=n&255,t[10]=(n=parseInt(e.slice(24,36),16))/1099511627776&255,t[11]=n/4294967296&255,t[12]=n>>>24&255,t[13]=n>>>16&255,t[14]=n>>>8&255,t[15]=n&255,t}function js(e){e=unescape(encodeURIComponent(e));for(var n=[],t=0;t<e.length;++t)n.push(e.charCodeAt(t));return n}var $s="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Zs="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function gr(e,n,t){function r(s,o,i,f){if(typeof s=="string"&&(s=js(s)),typeof o=="string"&&(o=yr(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|n,c[8]=c[8]&63|128,i){f=f||0;for(var h=0;h<16;++h)i[f+h]=c[h];return i}return bn(c)}try{r.name=e}catch{}return r.DNS=$s,r.URL=Zs,r}function Ys(e){if(typeof e=="string"){var n=unescape(encodeURIComponent(e));e=new Uint8Array(n.length);for(var t=0;t<n.length;++t)e[t]=n.charCodeAt(t)}return Gs(Hs(Ws(e),e.length*8))}function Gs(e){for(var n=[],t=e.length*32,r="0123456789abcdef",s=0;s<t;s+=8){var o=e[s>>5]>>>s%32&255,i=parseInt(r.charAt(o>>>4&15)+r.charAt(o&15),16);n.push(i)}return n}function wr(e){return(e+64>>>9<<4)+14+1}function Hs(e,n){e[n>>5]|=128<<n%32,e[wr(n)-1]=n;for(var t=1732584193,r=-271733879,s=-1732584194,o=271733878,i=0;i<e.length;i+=16){var f=t,c=r,h=s,b=o;t=pe(t,r,s,o,e[i],7,-680876936),o=pe(o,t,r,s,e[i+1],12,-389564586),s=pe(s,o,t,r,e[i+2],17,606105819),r=pe(r,s,o,t,e[i+3],22,-1044525330),t=pe(t,r,s,o,e[i+4],7,-176418897),o=pe(o,t,r,s,e[i+5],12,1200080426),s=pe(s,o,t,r,e[i+6],17,-1473231341),r=pe(r,s,o,t,e[i+7],22,-45705983),t=pe(t,r,s,o,e[i+8],7,1770035416),o=pe(o,t,r,s,e[i+9],12,-1958414417),s=pe(s,o,t,r,e[i+10],17,-42063),r=pe(r,s,o,t,e[i+11],22,-1990404162),t=pe(t,r,s,o,e[i+12],7,1804603682),o=pe(o,t,r,s,e[i+13],12,-40341101),s=pe(s,o,t,r,e[i+14],17,-1502002290),r=pe(r,s,o,t,e[i+15],22,1236535329),t=ye(t,r,s,o,e[i+1],5,-165796510),o=ye(o,t,r,s,e[i+6],9,-1069501632),s=ye(s,o,t,r,e[i+11],14,643717713),r=ye(r,s,o,t,e[i],20,-373897302),t=ye(t,r,s,o,e[i+5],5,-701558691),o=ye(o,t,r,s,e[i+10],9,38016083),s=ye(s,o,t,r,e[i+15],14,-660478335),r=ye(r,s,o,t,e[i+4],20,-405537848),t=ye(t,r,s,o,e[i+9],5,568446438),o=ye(o,t,r,s,e[i+14],9,-1019803690),s=ye(s,o,t,r,e[i+3],14,-187363961),r=ye(r,s,o,t,e[i+8],20,1163531501),t=ye(t,r,s,o,e[i+13],5,-1444681467),o=ye(o,t,r,s,e[i+2],9,-51403784),s=ye(s,o,t,r,e[i+7],14,1735328473),r=ye(r,s,o,t,e[i+12],20,-1926607734),t=ge(t,r,s,o,e[i+5],4,-378558),o=ge(o,t,r,s,e[i+8],11,-2022574463),s=ge(s,o,t,r,e[i+11],16,1839030562),r=ge(r,s,o,t,e[i+14],23,-35309556),t=ge(t,r,s,o,e[i+1],4,-1530992060),o=ge(o,t,r,s,e[i+4],11,1272893353),s=ge(s,o,t,r,e[i+7],16,-155497632),r=ge(r,s,o,t,e[i+10],23,-1094730640),t=ge(t,r,s,o,e[i+13],4,681279174),o=ge(o,t,r,s,e[i],11,-358537222),s=ge(s,o,t,r,e[i+3],16,-722521979),r=ge(r,s,o,t,e[i+6],23,76029189),t=ge(t,r,s,o,e[i+9],4,-640364487),o=ge(o,t,r,s,e[i+12],11,-421815835),s=ge(s,o,t,r,e[i+15],16,530742520),r=ge(r,s,o,t,e[i+2],23,-995338651),t=we(t,r,s,o,e[i],6,-198630844),o=we(o,t,r,s,e[i+7],10,1126891415),s=we(s,o,t,r,e[i+14],15,-1416354905),r=we(r,s,o,t,e[i+5],21,-57434055),t=we(t,r,s,o,e[i+12],6,1700485571),o=we(o,t,r,s,e[i+3],10,-1894986606),s=we(s,o,t,r,e[i+10],15,-1051523),r=we(r,s,o,t,e[i+1],21,-2054922799),t=we(t,r,s,o,e[i+8],6,1873313359),o=we(o,t,r,s,e[i+15],10,-30611744),s=we(s,o,t,r,e[i+6],15,-1560198380),r=we(r,s,o,t,e[i+13],21,1309151649),t=we(t,r,s,o,e[i+4],6,-145523070),o=we(o,t,r,s,e[i+11],10,-1120210379),s=we(s,o,t,r,e[i+2],15,718787259),r=we(r,s,o,t,e[i+9],21,-343485551),t=qe(t,f),r=qe(r,c),s=qe(s,h),o=qe(o,b)}return[t,r,s,o]}function Ws(e){if(e.length===0)return[];for(var n=e.length*8,t=new Uint32Array(wr(n)),r=0;r<n;r+=8)t[r>>5]|=(e[r/8]&255)<<r%32;return t}function qe(e,n){var t=(e&65535)+(n&65535),r=(e>>16)+(n>>16)+(t>>16);return r<<16|t&65535}function Xs(e,n){return e<<n|e>>>32-n}function Dt(e,n,t,r,s,o){return qe(Xs(qe(qe(n,e),qe(r,o)),s),t)}function pe(e,n,t,r,s,o,i){return Dt(n&t|~n&r,e,n,s,o,i)}function ye(e,n,t,r,s,o,i){return Dt(n&r|t&~r,e,n,s,o,i)}function ge(e,n,t,r,s,o,i){return Dt(n^t^r,e,n,s,o,i)}function we(e,n,t,r,s,o,i){return Dt(t^(n|~r),e,n,s,o,i)}var Js=gr("v3",48,Ys);function Qs(e,n,t,r){switch(e){case 0:return n&t^~n&r;case 1:return n^t^r;case 2:return n&t^n&r^t&r;case 3:return n^t^r}}function Xt(e,n){return e<<n|e>>>32-n}function eo(e){var n=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof e=="string"){var r=unescape(encodeURIComponent(e));e=[];for(var s=0;s<r.length;++s)e.push(r.charCodeAt(s))}else Array.isArray(e)||(e=Array.prototype.slice.call(e));e.push(128);for(var o=e.length/4+2,i=Math.ceil(o/16),f=new Array(i),c=0;c<i;++c){for(var h=new Uint32Array(16),b=0;b<16;++b)h[b]=e[c*64+b*4]<<24|e[c*64+b*4+1]<<16|e[c*64+b*4+2]<<8|e[c*64+b*4+3];f[c]=h}f[i-1][14]=(e.length-1)*8/Math.pow(2,32),f[i-1][14]=Math.floor(f[i-1][14]),f[i-1][15]=(e.length-1)*8&4294967295;for(var R=0;R<i;++R){for(var g=new Uint32Array(80),E=0;E<16;++E)g[E]=f[R][E];for(var B=16;B<80;++B)g[B]=Xt(g[B-3]^g[B-8]^g[B-14]^g[B-16],1);for(var U=t[0],O=t[1],T=t[2],F=t[3],L=t[4],$=0;$<80;++$){var Z=Math.floor($/20),H=Xt(U,5)+Qs(Z,O,T,F)+L+n[Z]+g[$]>>>0;L=F,F=T,T=Xt(O,30)>>>0,O=U,U=H}t[0]=t[0]+U>>>0,t[1]=t[1]+O>>>0,t[2]=t[2]+T>>>0,t[3]=t[3]+F>>>0,t[4]=t[4]+L>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var to=gr("v5",80,eo);const no="00000000-0000-0000-0000-000000000000";function ro(e){if(!En(e))throw TypeError("Invalid UUID");return parseInt(e.substr(14,1),16)}const so=Object.freeze(Object.defineProperty({__proto__:null,NIL:no,parse:yr,stringify:bn,v1:Vs,v3:Js,v4:gs,v5:to,validate:En,version:ro},Symbol.toStringTag,{value:"Module"}));class oo extends ws{async init(n){}async getIdentityToken(){if(!this.provider||!this.canAuthorize)throw Re.notConnectedError();if(!this.coreOptions)throw Kn.invalidParams("Please initialize Web3Auth with a valid options");this.status=Se.AUTHORIZING,this.emit(ke.AUTHORIZING,{connector:this.name});const n=await this.provider.request({method:Zt.GET_ACCOUNTS});if(n&&n.length>0){const t=ms(n[0],this.name);if(t&&!bs(t))return this.status=Se.AUTHORIZED,this.emit(ke.AUTHORIZED,{connector:this.name,identityTokenInfo:{idToken:t}}),{idToken:t};const r=await this.provider.request({method:"solana_chainId"}),s=this.coreOptions.chains.find(b=>b.chainId===r);if(!s)throw Kn.invalidParams("chainConfig is required before authentication");const{chainNamespace:o}=s,i={domain:window.location.origin,uri:window.location.href,address:n[0],chainId:parseInt(r,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},f=await Es(i,o),c=await this.provider.request({method:Zt.SIGN_MESSAGE,params:{data:f,display:"utf8"}}),h=await vs(o,c,f,this.name,this.coreOptions.sessionTime,this.coreOptions.clientId,this.coreOptions.web3AuthNetwork);return xs(n[0],this.name,h),this.status=Se.AUTHORIZED,this.emit(ke.AUTHORIZED,{connector:this.name,identityTokenInfo:{idToken:h}}),{idToken:h}}throw Re.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();const n=await this.provider.request({method:Zt.GET_ACCOUNTS});n&&n.length>0&&Ss(n[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(ke.DISCONNECTED)}}var io=function(e,n,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(e):r?r.value:n.get(e)},ao=function(e,n,t,r,s){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof n=="function"?e!==n||!s:!n.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?s.call(e,t):s?s.value=t:n.set(e,t),t},xt;let ft;const Kt=new Set;function co(e){dt=void 0,Kt.add(e)}function uo(e){dt=void 0,Kt.delete(e)}const Qe={};function Fa(){if(ft||(ft=Object.freeze({register:Vn,get:fo,on:lo}),typeof window>"u"))return ft;const e=Object.freeze({register:Vn});try{window.addEventListener("wallet-standard:register-wallet",({detail:n})=>n(e))}catch(n){console.error(`wallet-standard:register-wallet event listener could not be added
`,n)}try{window.dispatchEvent(new ho(e))}catch(n){console.error(`wallet-standard:app-ready event could not be dispatched
`,n)}return ft}function Vn(...e){var n;return e=e.filter(t=>!Kt.has(t)),e.length?(e.forEach(t=>co(t)),(n=Qe.register)==null||n.forEach(t=>jn(()=>t(...e))),function(){var r;e.forEach(s=>uo(s)),(r=Qe.unregister)==null||r.forEach(s=>jn(()=>s(...e)))}):()=>{}}let dt;function fo(){return dt||(dt=[...Kt]),dt}function lo(e,n){var t;return(t=Qe[e])!=null&&t.push(n)||(Qe[e]=[n]),function(){var s;Qe[e]=(s=Qe[e])==null?void 0:s.filter(o=>n!==o)}}function jn(e){try{e()}catch(n){console.error(n)}}class ho extends Event{get detail(){return io(this,xt,"f")}get type(){return"wallet-standard:app-ready"}constructor(n){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),xt.set(this,void 0),ao(this,xt,n,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}}xt=new WeakMap;const mr="solana:signAndSendTransaction",br="solana:signMessage",ln="solana:signTransaction",Er="standard:connect",po="standard:disconnect";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xn=BigInt(0),hn=BigInt(1);function Ye(e,n=""){if(typeof e!="boolean"){const t=n&&`"${n}"`;throw new Error(t+"expected boolean, got type="+typeof e)}return e}function Ae(e,n,t=""){const r=Ft(e),s=e==null?void 0:e.length,o=n!==void 0;if(!r||o&&s!==n){const i=t&&`"${t}" `,f=o?` of length ${n}`:"",c=r?`length=${s}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+f+", got "+c)}return e}function Et(e){const n=e.toString(16);return n.length&1?"0"+n:n}function vr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?xn:BigInt("0x"+e)}function qt(e){return vr(Ze(e))}function lt(e){return As(e),vr(Ze(Uint8Array.from(e).reverse()))}function Sn(e,n){return Bt(e.toString(16).padStart(n*2,"0"))}function xr(e,n){return Sn(e,n).reverse()}function ce(e,n,t){let r;if(typeof n=="string")try{r=Bt(n)}catch(o){throw new Error(e+" must be hex string or Uint8Array, cause: "+o)}else if(Ft(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(e+" of length "+t+" expected, got "+s);return r}function $n(e){return Uint8Array.from(e)}const Jt=e=>typeof e=="bigint"&&xn<=e;function yo(e,n,t){return Jt(e)&&Jt(n)&&Jt(t)&&n<=e&&e<t}function pn(e,n,t,r){if(!yo(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function Sr(e){let n;for(n=0;e>xn;e>>=hn,n+=1);return n}const pt=e=>(hn<<BigInt(e))-hn;function go(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=E=>new Uint8Array(E),s=E=>Uint8Array.of(E);let o=r(e),i=r(e),f=0;const c=()=>{o.fill(1),i.fill(0),f=0},h=(...E)=>t(i,o,...E),b=(E=r(0))=>{i=h(s(0),E),o=h(),E.length!==0&&(i=h(s(1),E),o=h())},R=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let E=0;const B=[];for(;E<n;){o=h();const U=o.slice();B.push(U),E+=o.length}return Oe(...B)};return(E,B)=>{c(),b(E);let U;for(;!(U=B(R()));)b();return c(),U}}function yt(e,n,t={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,o,i){const f=e[s];if(i&&f===void 0)return;const c=typeof f;if(c!==o||f===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${c}`)}Object.entries(n).forEach(([s,o])=>r(s,o,!1)),Object.entries(t).forEach(([s,o])=>r(s,o,!0))}function It(e){const n=new WeakMap;return(t,...r)=>{const s=n.get(t);if(s!==void 0)return s;const o=e(t,...r);return n.set(t,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const be=BigInt(0),he=BigInt(1),Ve=BigInt(2),Ar=BigInt(3),Br=BigInt(4),Ir=BigInt(5),wo=BigInt(7),Rr=BigInt(8),mo=BigInt(9),kr=BigInt(16);function de(e,n){const t=e%n;return t>=be?t:n+t}function ae(e,n,t){let r=e;for(;n-- >be;)r*=r,r%=t;return r}function Zn(e,n){if(e===be)throw new Error("invert: expected non-zero number");if(n<=be)throw new Error("invert: expected positive modulus, got "+n);let t=de(e,n),r=n,s=be,o=he;for(;t!==be;){const f=r/t,c=r%t,h=s-o*f;r=t,t=c,s=o,o=h}if(r!==he)throw new Error("invert: does not exist");return de(s,n)}function An(e,n,t){if(!e.eql(e.sqr(n),t))throw new Error("Cannot find square root")}function _r(e,n){const t=(e.ORDER+he)/Br,r=e.pow(n,t);return An(e,r,n),r}function bo(e,n){const t=(e.ORDER-Ir)/Rr,r=e.mul(n,Ve),s=e.pow(r,t),o=e.mul(n,s),i=e.mul(e.mul(o,Ve),s),f=e.mul(o,e.sub(i,e.ONE));return An(e,f,n),f}function Eo(e){const n=Ge(e),t=Or(e),r=t(n,n.neg(n.ONE)),s=t(n,r),o=t(n,n.neg(r)),i=(e+wo)/kr;return(f,c)=>{let h=f.pow(c,i),b=f.mul(h,r);const R=f.mul(h,s),g=f.mul(h,o),E=f.eql(f.sqr(b),c),B=f.eql(f.sqr(R),c);h=f.cmov(h,b,E),b=f.cmov(g,R,B);const U=f.eql(f.sqr(b),c),O=f.cmov(h,b,U);return An(f,O,c),O}}function Or(e){if(e<Ar)throw new Error("sqrt is not defined for small field");let n=e-he,t=0;for(;n%Ve===be;)n/=Ve,t++;let r=Ve;const s=Ge(e);for(;Yn(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return _r;let o=s.pow(r,n);const i=(n+he)/Ve;return function(c,h){if(c.is0(h))return h;if(Yn(c,h)!==1)throw new Error("Cannot find square root");let b=t,R=c.mul(c.ONE,o),g=c.pow(h,n),E=c.pow(h,i);for(;!c.eql(g,c.ONE);){if(c.is0(g))return c.ZERO;let B=1,U=c.sqr(g);for(;!c.eql(U,c.ONE);)if(B++,U=c.sqr(U),B===b)throw new Error("Cannot find square root");const O=he<<BigInt(b-B-1),T=c.pow(R,O);b=B,R=c.sqr(T),g=c.mul(g,R),E=c.mul(E,T)}return E}}function vo(e){return e%Br===Ar?_r:e%Rr===Ir?bo:e%kr===mo?Eo(e):Or(e)}const xo=(e,n)=>(de(e,n)&he)===he,So=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ao(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=So.reduce((r,s)=>(r[s]="function",r),n);return yt(e,t),e}function Bo(e,n,t){if(t<be)throw new Error("invalid exponent, negatives unsupported");if(t===be)return e.ONE;if(t===he)return n;let r=e.ONE,s=n;for(;t>be;)t&he&&(r=e.mul(r,s)),s=e.sqr(s),t>>=he;return r}function Tr(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),s=n.reduce((i,f,c)=>e.is0(f)?i:(r[c]=i,e.mul(i,f)),e.ONE),o=e.inv(s);return n.reduceRight((i,f,c)=>e.is0(f)?i:(r[c]=e.mul(i,r[c]),e.mul(i,f)),o),r}function Yn(e,n){const t=(e.ORDER-he)/Ve,r=e.pow(n,t),s=e.eql(r,e.ONE),o=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function Ur(e,n){n!==void 0&&Bs(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Ge(e,n,t=!1,r={}){if(e<=be)throw new Error("invalid field: expected ORDER > 0, got "+e);let s,o,i=!1,f;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const g=n;g.BITS&&(s=g.BITS),g.sqrt&&(o=g.sqrt),typeof g.isLE=="boolean"&&(t=g.isLE),typeof g.modFromBytes=="boolean"&&(i=g.modFromBytes),f=g.allowedLengths}else typeof n=="number"&&(s=n),r.sqrt&&(o=r.sqrt);const{nBitLength:c,nByteLength:h}=Ur(e,s);if(h>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const R=Object.freeze({ORDER:e,isLE:t,BITS:c,BYTES:h,MASK:pt(c),ZERO:be,ONE:he,allowedLengths:f,create:g=>de(g,e),isValid:g=>{if(typeof g!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof g);return be<=g&&g<e},is0:g=>g===be,isValidNot0:g=>!R.is0(g)&&R.isValid(g),isOdd:g=>(g&he)===he,neg:g=>de(-g,e),eql:(g,E)=>g===E,sqr:g=>de(g*g,e),add:(g,E)=>de(g+E,e),sub:(g,E)=>de(g-E,e),mul:(g,E)=>de(g*E,e),pow:(g,E)=>Bo(R,g,E),div:(g,E)=>de(g*Zn(E,e),e),sqrN:g=>g*g,addN:(g,E)=>g+E,subN:(g,E)=>g-E,mulN:(g,E)=>g*E,inv:g=>Zn(g,e),sqrt:o||(g=>(b||(b=vo(e)),b(R,g))),toBytes:g=>t?xr(g,h):Sn(g,h),fromBytes:(g,E=!0)=>{if(f){if(!f.includes(g.length)||g.length>h)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+g.length);const U=new Uint8Array(h);U.set(g,t?0:U.length-g.length),g=U}if(g.length!==h)throw new Error("Field.fromBytes: expected "+h+" bytes, got "+g.length);let B=t?lt(g):qt(g);if(i&&(B=de(B,e)),!E&&!R.isValid(B))throw new Error("invalid field element: outside of range 0..ORDER");return B},invertBatch:g=>Tr(R,g),cmov:(g,E,B)=>B?E:g});return Object.freeze(R)}function Lr(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Cr(e){const n=Lr(e);return n+Math.ceil(n/2)}function Io(e,n,t=!1){const r=e.length,s=Lr(n),o=Cr(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const i=t?lt(e):qt(e),f=de(i,n-he)+he;return t?xr(f,s):Sn(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),je=BigInt(1);function Rt(e,n){const t=n.negate();return e?t:n}function $e(e,n){const t=Tr(e.Fp,n.map(r=>r.Z));return n.map((r,s)=>e.fromAffine(r.toAffine(t[s])))}function Nr(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Qt(e,n){Nr(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),s=2**e,o=pt(e),i=BigInt(e);return{windows:t,windowSize:r,mask:o,maxNumber:s,shiftBy:i}}function Gn(e,n,t){const{windowSize:r,mask:s,maxNumber:o,shiftBy:i}=t;let f=Number(e&s),c=e>>i;f>r&&(f-=o,c+=je);const h=n*r,b=h+Math.abs(f)-1,R=f===0,g=f<0,E=n%2!==0;return{nextN:c,offset:b,isZero:R,isNeg:g,isNegF:E,offsetF:h}}function Ro(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function ko(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const en=new WeakMap,zr=new WeakMap;function tn(e){return zr.get(e)||1}function Hn(e){if(e!==ot)throw new Error("invalid wNAF")}class Fr{constructor(n,t){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=t}_unsafeLadder(n,t,r=this.ZERO){let s=n;for(;t>ot;)t&je&&(r=r.add(s)),s=s.double(),t>>=je;return r}precomputeWindow(n,t){const{windows:r,windowSize:s}=Qt(t,this.bits),o=[];let i=n,f=i;for(let c=0;c<r;c++){f=i,o.push(f);for(let h=1;h<s;h++)f=f.add(i),o.push(f);i=f.double()}return o}wNAF(n,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=Qt(n,this.bits);for(let f=0;f<i.windows;f++){const{nextN:c,offset:h,isZero:b,isNeg:R,isNegF:g,offsetF:E}=Gn(r,f,i);r=c,b?o=o.add(Rt(g,t[E])):s=s.add(Rt(R,t[h]))}return Hn(r),{p:s,f:o}}wNAFUnsafe(n,t,r,s=this.ZERO){const o=Qt(n,this.bits);for(let i=0;i<o.windows&&r!==ot;i++){const{nextN:f,offset:c,isZero:h,isNeg:b}=Gn(r,i,o);if(r=f,!h){const R=t[c];s=s.add(b?R.negate():R)}}return Hn(r),s}getPrecomputes(n,t,r){let s=en.get(t);return s||(s=this.precomputeWindow(t,n),n!==1&&(typeof r=="function"&&(s=r(s)),en.set(t,s))),s}cached(n,t,r){const s=tn(n);return this.wNAF(s,this.getPrecomputes(s,n,r),t)}unsafe(n,t,r,s){const o=tn(n);return o===1?this._unsafeLadder(n,t,s):this.wNAFUnsafe(o,this.getPrecomputes(o,n,r),t,s)}createCache(n,t){Nr(t,this.bits),zr.set(n,t),en.delete(n)}hasCache(n){return tn(n)!==1}}function _o(e,n,t,r){let s=n,o=e.ZERO,i=e.ZERO;for(;t>ot||r>ot;)t&je&&(o=o.add(s)),r&je&&(i=i.add(s)),s=s.double(),t>>=je,r>>=je;return{p1:o,p2:i}}function Dr(e,n,t,r){Ro(t,e),ko(r,n);const s=t.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,f=Sr(BigInt(s));let c=1;f>12?c=f-3:f>4?c=f-2:f>0&&(c=2);const h=pt(c),b=new Array(Number(h)+1).fill(i),R=Math.floor((n.BITS-1)/c)*c;let g=i;for(let E=R;E>=0;E-=c){b.fill(i);for(let U=0;U<o;U++){const O=r[U],T=Number(O>>BigInt(E)&h);b[T]=b[T].add(t[U])}let B=i;for(let U=b.length-1,O=i;U>0;U--)O=O.add(b[U]),B=B.add(O);if(g=g.add(B),E!==0)for(let U=0;U<c;U++)g=g.double()}return g}function Wn(e,n,t){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Ao(n),n}else return Ge(e,{isLE:t})}function Kr(e,n,t={},r){if(r===void 0&&(r=e==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const c of["p","n","h"]){const h=n[c];if(!(typeof h=="bigint"&&h>ot))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Wn(n.p,t.Fp,r),o=Wn(n.n,t.Fn,r),f=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const c of f)if(!s.isValid(n[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:s,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ke=BigInt(0),le=BigInt(1),nn=BigInt(2),Oo=BigInt(8);function To(e,n,t,r){const s=e.sqr(t),o=e.sqr(r),i=e.add(e.mul(n.a,s),o),f=e.add(e.ONE,e.mul(n.d,e.mul(s,o)));return e.eql(i,f)}function Uo(e,n={}){const t=Kr("edwards",e,n,n.FpFnLE),{Fp:r,Fn:s}=t;let o=t.CURVE;const{h:i}=o;yt(n,{},{uvRatio:"function"});const f=nn<<BigInt(s.BYTES*8)-le,c=O=>r.create(O),h=n.uvRatio||((O,T)=>{try{return{isValid:!0,value:r.sqrt(r.div(O,T))}}catch{return{isValid:!1,value:Ke}}});if(!To(r,o,o.Gx,o.Gy))throw new Error("bad curve params: generator point");function b(O,T,F=!1){const L=F?le:Ke;return pn("coordinate "+O,T,L,f),T}function R(O){if(!(O instanceof B))throw new Error("ExtendedPoint expected")}const g=It((O,T)=>{const{X:F,Y:L,Z:$}=O,Z=O.is0();T==null&&(T=Z?Oo:r.inv($));const H=c(F*T),te=c(L*T),Q=r.mul($,T);if(Z)return{x:Ke,y:le};if(Q!==le)throw new Error("invZ was invalid");return{x:H,y:te}}),E=It(O=>{const{a:T,d:F}=o;if(O.is0())throw new Error("bad point: ZERO");const{X:L,Y:$,Z,T:H}=O,te=c(L*L),Q=c($*$),y=c(Z*Z),w=c(y*y),k=c(te*T),I=c(y*c(k+Q)),v=c(w+c(F*c(te*Q)));if(I!==v)throw new Error("bad point: equation left != right (1)");const m=c(L*$),A=c(Z*H);if(m!==A)throw new Error("bad point: equation left != right (2)");return!0});class B{constructor(T,F,L,$){this.X=b("x",T),this.Y=b("y",F),this.Z=b("z",L,!0),this.T=b("t",$),Object.freeze(this)}static CURVE(){return o}static fromAffine(T){if(T instanceof B)throw new Error("extended point not allowed");const{x:F,y:L}=T||{};return b("x",F),b("y",L),new B(F,L,le,c(F*L))}static fromBytes(T,F=!1){const L=r.BYTES,{a:$,d:Z}=o;T=$n(Ae(T,L,"point")),Ye(F,"zip215");const H=$n(T),te=T[L-1];H[L-1]=te&-129;const Q=lt(H),y=F?f:r.ORDER;pn("point.y",Q,Ke,y);const w=c(Q*Q),k=c(w-le),I=c(Z*w-$);let{isValid:v,value:m}=h(k,I);if(!v)throw new Error("bad point: invalid y coordinate");const A=(m&le)===le,z=(te&128)!==0;if(!F&&m===Ke&&z)throw new Error("bad point: x=0 and x_0=1");return z!==A&&(m=c(-m)),B.fromAffine({x:m,y:Q})}static fromHex(T,F=!1){return B.fromBytes(ce("point",T),F)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(T=8,F=!0){return U.createCache(this,T),F||this.multiply(nn),this}assertValidity(){E(this)}equals(T){R(T);const{X:F,Y:L,Z:$}=this,{X:Z,Y:H,Z:te}=T,Q=c(F*te),y=c(Z*$),w=c(L*te),k=c(H*$);return Q===y&&w===k}is0(){return this.equals(B.ZERO)}negate(){return new B(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:T}=o,{X:F,Y:L,Z:$}=this,Z=c(F*F),H=c(L*L),te=c(nn*c($*$)),Q=c(T*Z),y=F+L,w=c(c(y*y)-Z-H),k=Q+H,I=k-te,v=Q-H,m=c(w*I),A=c(k*v),z=c(w*v),K=c(I*k);return new B(m,A,K,z)}add(T){R(T);const{a:F,d:L}=o,{X:$,Y:Z,Z:H,T:te}=this,{X:Q,Y:y,Z:w,T:k}=T,I=c($*Q),v=c(Z*y),m=c(te*L*k),A=c(H*w),z=c(($+Z)*(Q+y)-I-v),K=A-m,j=A+m,P=c(v-F*I),V=c(z*K),G=c(j*P),p=c(z*P),a=c(K*j);return new B(V,G,a,p)}subtract(T){return this.add(T.negate())}multiply(T){if(!s.isValidNot0(T))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:F,f:L}=U.cached(this,T,$=>$e(B,$));return $e(B,[F,L])[0]}multiplyUnsafe(T,F=B.ZERO){if(!s.isValid(T))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return T===Ke?B.ZERO:this.is0()||T===le?this:U.unsafe(this,T,L=>$e(B,L),F)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return U.unsafe(this,o.n).is0()}toAffine(T){return g(this,T)}clearCofactor(){return i===le?this:this.multiplyUnsafe(i)}toBytes(){const{x:T,y:F}=this.toAffine(),L=r.toBytes(F);return L[L.length-1]|=T&le?128:0,L}toHex(){return Ze(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(T){return $e(B,T)}static msm(T,F){return Dr(B,s,T,F)}_setWindowSize(T){this.precompute(T)}toRawBytes(){return this.toBytes()}}B.BASE=new B(o.Gx,o.Gy,le,c(o.Gx*o.Gy)),B.ZERO=new B(Ke,le,le,Ke),B.Fp=r,B.Fn=s;const U=new Fr(B,s.BITS);return B.BASE.precompute(8),B}function Lo(e,n,t={}){if(typeof n!="function")throw new Error('"hash" function param is required');yt(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=t,{BASE:s,Fp:o,Fn:i}=e,f=t.randomBytes||vn,c=t.adjustScalarBytes||(y=>y),h=t.domain||((y,w,k)=>{if(Ye(k,"phflag"),w.length||k)throw new Error("Contexts/pre-hash are not supported");return y});function b(y){return i.create(lt(y))}function R(y){const w=L.secretKey;y=ce("private key",y,w);const k=ce("hashed private key",n(y),2*w),I=c(k.slice(0,w)),v=k.slice(w,2*w),m=b(I);return{head:I,prefix:v,scalar:m}}function g(y){const{head:w,prefix:k,scalar:I}=R(y),v=s.multiply(I),m=v.toBytes();return{head:w,prefix:k,scalar:I,point:v,pointBytes:m}}function E(y){return g(y).pointBytes}function B(y=Uint8Array.of(),...w){const k=Oe(...w);return b(n(h(k,ce("context",y),!!r)))}function U(y,w,k={}){y=ce("message",y),r&&(y=r(y));const{prefix:I,scalar:v,pointBytes:m}=g(w),A=B(k.context,I,y),z=s.multiply(A).toBytes(),K=B(k.context,z,m,y),j=i.create(A+K*v);if(!i.isValid(j))throw new Error("sign failed: invalid s");const P=Oe(z,i.toBytes(j));return Ae(P,L.signature,"result")}const O={zip215:!0};function T(y,w,k,I=O){const{context:v,zip215:m}=I,A=L.signature;y=ce("signature",y,A),w=ce("message",w),k=ce("publicKey",k,L.publicKey),m!==void 0&&Ye(m,"zip215"),r&&(w=r(w));const z=A/2,K=y.subarray(0,z),j=lt(y.subarray(z,A));let P,V,G;try{P=e.fromBytes(k,m),V=e.fromBytes(K,m),G=s.multiplyUnsafe(j)}catch{return!1}if(!m&&P.isSmallOrder())return!1;const p=B(v,V.toBytes(),P.toBytes(),w);return V.add(P.multiplyUnsafe(p)).subtract(G).clearCofactor().is0()}const F=o.BYTES,L={secretKey:F,publicKey:F,signature:2*F,seed:F};function $(y=f(L.seed)){return Ae(y,L.seed,"seed")}function Z(y){const w=Q.randomSecretKey(y);return{secretKey:w,publicKey:E(w)}}function H(y){return Ft(y)&&y.length===i.BYTES}function te(y,w){try{return!!e.fromBytes(y,w)}catch{return!1}}const Q={getExtendedPublicKey:g,randomSecretKey:$,isValidSecretKey:H,isValidPublicKey:te,toMontgomery(y){const{y:w}=e.fromBytes(y),k=L.publicKey,I=k===32;if(!I&&k!==57)throw new Error("only defined for 25519 and 448");const v=I?o.div(le+w,le-w):o.div(w-le,w+le);return o.toBytes(v)},toMontgomerySecret(y){const w=L.secretKey;Ae(y,w);const k=n(y.subarray(0,w));return c(k).subarray(0,w)},randomPrivateKey:$,precompute(y=8,w=e.BASE){return w.precompute(y,!1)}};return Object.freeze({keygen:Z,getPublicKey:E,sign:U,verify:T,utils:Q,Point:e,lengths:L})}function Co(e){const n={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=Ge(n.n,e.nBitLength,!0),s={Fp:t,Fn:r,uvRatio:e.uvRatio},o={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:n,curveOpts:s,hash:e.hash,eddsaOpts:o}}function No(e,n){const t=n.Point;return Object.assign({},n,{ExtendedPoint:t,CURVE:e,nBitLength:t.Fn.BITS,nByteLength:t.Fn.BYTES})}function zo(e){const{CURVE:n,curveOpts:t,hash:r,eddsaOpts:s}=Co(e),o=Uo(n,t),i=Lo(o,r,s);return No(e,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fo=BigInt(1),Xn=BigInt(2);BigInt(3);const Do=BigInt(5),Ko=BigInt(8),Bn=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),qr={p:Bn,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Ko,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function qo(e){const n=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),o=Bn,f=e*e%o*e%o,c=ae(f,Xn,o)*f%o,h=ae(c,Fo,o)*e%o,b=ae(h,Do,o)*h%o,R=ae(b,n,o)*b%o,g=ae(R,t,o)*R%o,E=ae(g,r,o)*g%o,B=ae(E,s,o)*E%o,U=ae(B,s,o)*E%o,O=ae(U,n,o)*b%o;return{pow_p_5_8:ae(O,Xn,o)*e%o,b2:f}}function Mo(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Jn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Po(e,n){const t=Bn,r=de(n*n*n,t),s=de(r*r*n,t),o=qo(e*s).pow_p_5_8;let i=de(e*r*o,t);const f=de(n*i*i,t),c=i,h=de(i*Jn,t),b=f===e,R=f===de(-e,t),g=f===de(-e*Jn,t);return b&&(i=c),(R||g)&&(i=h),xo(i,t)&&(i=de(-i,t)),{isValid:b||R,value:i}}const Vo=Ge(qr.p,{isLE:!0}),jo={...qr,Fp:Vo,hash:Fs,adjustScalarBytes:Mo,uvRatio:Po},gt=zo(jo);var rn,Qn;function $o(){if(Qn)return rn;Qn=1;var e=Is().Buffer;function n(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),f=i.charCodeAt(0);if(r[f]!==255)throw new TypeError(i+" is ambiguous");r[f]=o}var c=t.length,h=t.charAt(0),b=Math.log(c)/Math.log(256),R=Math.log(256)/Math.log(c);function g(U){if((Array.isArray(U)||U instanceof Uint8Array)&&(U=e.from(U)),!e.isBuffer(U))throw new TypeError("Expected Buffer");if(U.length===0)return"";for(var O=0,T=0,F=0,L=U.length;F!==L&&U[F]===0;)F++,O++;for(var $=(L-F)*R+1>>>0,Z=new Uint8Array($);F!==L;){for(var H=U[F],te=0,Q=$-1;(H!==0||te<T)&&Q!==-1;Q--,te++)H+=256*Z[Q]>>>0,Z[Q]=H%c>>>0,H=H/c>>>0;if(H!==0)throw new Error("Non-zero carry");T=te,F++}for(var y=$-T;y!==$&&Z[y]===0;)y++;for(var w=h.repeat(O);y<$;++y)w+=t.charAt(Z[y]);return w}function E(U){if(typeof U!="string")throw new TypeError("Expected String");if(U.length===0)return e.alloc(0);for(var O=0,T=0,F=0;U[O]===h;)T++,O++;for(var L=(U.length-O)*b+1>>>0,$=new Uint8Array(L);O<U.length;){var Z=U.charCodeAt(O);if(Z>255)return;var H=r[Z];if(H===255)return;for(var te=0,Q=L-1;(H!==0||te<F)&&Q!==-1;Q--,te++)H+=c*$[Q]>>>0,$[Q]=H%256>>>0,H=H/256>>>0;if(H!==0)throw new Error("Non-zero carry");F=te,O++}for(var y=L-F;y!==L&&$[y]===0;)y++;var w=e.allocUnsafe(T+(L-y));w.fill(0,0,T);for(var k=T;y!==L;)w[k++]=$[y++];return w}function B(U){var O=E(U);if(O)return O;throw new Error("Non-base"+c+" character")}return{encode:g,decodeUnsafe:E,decode:B}}return rn=n,rn}var sn,er;function Mr(){if(er)return sn;er=1;var e=$o(),n="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return sn=e(n),sn}var Zo=Mr();const _e=hr(Zo);var re={};function Ne(e,n,t){return n<=e&&e<=t}function Mt(e){if(e===void 0)return{};if(e===Object(e))return e;throw TypeError("Could not convert argument to dictionary")}function Yo(e){for(var n=String(e),t=n.length,r=0,s=[];r<t;){var o=n.charCodeAt(r);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(r===t-1)s.push(65533);else{var i=e.charCodeAt(r+1);if(56320<=i&&i<=57343){var f=o&1023,c=i&1023;s.push(65536+(f<<10)+c),r+=1}else s.push(65533)}r+=1}return s}function Go(e){for(var n="",t=0;t<e.length;++t){var r=e[t];r<=65535?n+=String.fromCharCode(r):(r-=65536,n+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return n}var kt=-1;function In(e){this.tokens=[].slice.call(e)}In.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():kt},prepend:function(e){if(Array.isArray(e))for(var n=e;n.length;)this.tokens.unshift(n.pop());else this.tokens.unshift(e)},push:function(e){if(Array.isArray(e))for(var n=e;n.length;)this.tokens.push(n.shift());else this.tokens.push(e)}};var it=-1;function on(e,n){if(e)throw TypeError("Decoder error");return n||65533}var _t="utf-8";function Ot(e,n){if(!(this instanceof Ot))return new Ot(e,n);if(e=e!==void 0?String(e).toLowerCase():_t,e!==_t)throw new Error("Encoding not supported. Only utf-8 is supported");n=Mt(n),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!n.fatal,this._ignoreBOM=!!n.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}Ot.prototype={decode:function(n,t){var r;typeof n=="object"&&n instanceof ArrayBuffer?r=new Uint8Array(n):typeof n=="object"&&"buffer"in n&&n.buffer instanceof ArrayBuffer?r=new Uint8Array(n.buffer,n.byteOffset,n.byteLength):r=new Uint8Array(0),t=Mt(t),this._streaming||(this._decoder=new Ho({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new In(r),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==it);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===it)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Go(o)}};function Tt(e,n){if(!(this instanceof Tt))return new Tt(e,n);if(e=e!==void 0?String(e).toLowerCase():_t,e!==_t)throw new Error("Encoding not supported. Only utf-8 is supported");n=Mt(n),this._streaming=!1,this._encoder=null,this._options={fatal:!!n.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}Tt.prototype={encode:function(n,t){n=n?String(n):"",t=Mt(t),this._streaming||(this._encoder=new Wo(this._options)),this._streaming=!!t.stream;for(var r=[],s=new In(Yo(n)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==it);)Array.isArray(o)?r.push.apply(r,o):r.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==it;)Array.isArray(o)?r.push.apply(r,o):r.push(o);this._encoder=null}return new Uint8Array(r)}};function Ho(e){var n=e.fatal,t=0,r=0,s=0,o=128,i=191;this.handler=function(f,c){if(c===kt&&s!==0)return s=0,on(n);if(c===kt)return it;if(s===0){if(Ne(c,0,127))return c;if(Ne(c,194,223))s=1,t=c-192;else if(Ne(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(Ne(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return on(n);return t=t<<6*s,null}if(!Ne(c,o,i))return t=s=r=0,o=128,i=191,f.prepend(c),on(n);if(o=128,i=191,r+=1,t+=c-128<<6*(s-r),r!==s)return null;var h=t;return t=s=r=0,h}}function Wo(e){e.fatal,this.handler=function(n,t){if(t===kt)return it;if(Ne(t,0,127))return t;var r,s;Ne(t,128,2047)?(r=1,s=192):Ne(t,2048,65535)?(r=2,s=224):Ne(t,65536,1114111)&&(r=3,s=240);for(var o=[(t>>6*r)+s];r>0;){var i=t>>6*(r-1);o.push(128|i&63),r-=1}return o}}const Xo=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:Ot,TextEncoder:Tt},Symbol.toStringTag,{value:"Module"})),Jo=pr(Xo);var tr;function Qo(){if(tr)return re;tr=1;var e=re&&re.__createBinding||(Object.create?(function(y,w,k,I){I===void 0&&(I=k),Object.defineProperty(y,I,{enumerable:!0,get:function(){return w[k]}})}):(function(y,w,k,I){I===void 0&&(I=k),y[I]=w[k]})),n=re&&re.__setModuleDefault||(Object.create?(function(y,w){Object.defineProperty(y,"default",{enumerable:!0,value:w})}):function(y,w){y.default=w}),t=re&&re.__decorate||function(y,w,k,I){var v=arguments.length,m=v<3?w:I===null?I=Object.getOwnPropertyDescriptor(w,k):I,A;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")m=Reflect.decorate(y,w,k,I);else for(var z=y.length-1;z>=0;z--)(A=y[z])&&(m=(v<3?A(m):v>3?A(w,k,m):A(w,k))||m);return v>3&&m&&Object.defineProperty(w,k,m),m},r=re&&re.__importStar||function(y){if(y&&y.__esModule)return y;var w={};if(y!=null)for(var k in y)k!=="default"&&Object.hasOwnProperty.call(y,k)&&e(w,y,k);return n(w,y),w},s=re&&re.__importDefault||function(y){return y&&y.__esModule?y:{default:y}};Object.defineProperty(re,"__esModule",{value:!0}),re.deserializeUnchecked=re.deserialize=re.serialize=re.BinaryReader=re.BinaryWriter=re.BorshError=re.baseDecode=re.baseEncode=void 0;const o=s(lr()),i=s(Mr()),f=r(Jo),c=typeof TextDecoder!="function"?f.TextDecoder:TextDecoder,h=new c("utf-8",{fatal:!0});function b(y){return typeof y=="string"&&(y=fe.from(y,"utf8")),i.default.encode(fe.from(y))}re.baseEncode=b;function R(y){return fe.from(i.default.decode(y))}re.baseDecode=R;const g=1024;class E extends Error{constructor(w){super(w),this.fieldPath=[],this.originalMessage=w}addToFieldPath(w){this.fieldPath.splice(0,0,w),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}re.BorshError=E;class B{constructor(){this.buf=fe.alloc(g),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=fe.concat([this.buf,fe.alloc(g)]))}writeU8(w){this.maybeResize(),this.buf.writeUInt8(w,this.length),this.length+=1}writeU16(w){this.maybeResize(),this.buf.writeUInt16LE(w,this.length),this.length+=2}writeU32(w){this.maybeResize(),this.buf.writeUInt32LE(w,this.length),this.length+=4}writeU64(w){this.maybeResize(),this.writeBuffer(fe.from(new o.default(w).toArray("le",8)))}writeU128(w){this.maybeResize(),this.writeBuffer(fe.from(new o.default(w).toArray("le",16)))}writeU256(w){this.maybeResize(),this.writeBuffer(fe.from(new o.default(w).toArray("le",32)))}writeU512(w){this.maybeResize(),this.writeBuffer(fe.from(new o.default(w).toArray("le",64)))}writeBuffer(w){this.buf=fe.concat([fe.from(this.buf.subarray(0,this.length)),w,fe.alloc(g)]),this.length+=w.length}writeString(w){this.maybeResize();const k=fe.from(w,"utf8");this.writeU32(k.length),this.writeBuffer(k)}writeFixedArray(w){this.writeBuffer(fe.from(w))}writeArray(w,k){this.maybeResize(),this.writeU32(w.length);for(const I of w)this.maybeResize(),k(I)}toArray(){return this.buf.subarray(0,this.length)}}re.BinaryWriter=B;function U(y,w,k){const I=k.value;k.value=function(...v){try{return I.apply(this,v)}catch(m){if(m instanceof RangeError){const A=m.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(A)>=0)throw new E("Reached the end of buffer when deserializing")}throw m}}}class O{constructor(w){this.buf=w,this.offset=0}readU8(){const w=this.buf.readUInt8(this.offset);return this.offset+=1,w}readU16(){const w=this.buf.readUInt16LE(this.offset);return this.offset+=2,w}readU32(){const w=this.buf.readUInt32LE(this.offset);return this.offset+=4,w}readU64(){const w=this.readBuffer(8);return new o.default(w,"le")}readU128(){const w=this.readBuffer(16);return new o.default(w,"le")}readU256(){const w=this.readBuffer(32);return new o.default(w,"le")}readU512(){const w=this.readBuffer(64);return new o.default(w,"le")}readBuffer(w){if(this.offset+w>this.buf.length)throw new E(`Expected buffer length ${w} isn't within bounds`);const k=this.buf.slice(this.offset,this.offset+w);return this.offset+=w,k}readString(){const w=this.readU32(),k=this.readBuffer(w);try{return h.decode(k)}catch(I){throw new E(`Error decoding UTF-8 string: ${I}`)}}readFixedArray(w){return new Uint8Array(this.readBuffer(w))}readArray(w){const k=this.readU32(),I=Array();for(let v=0;v<k;++v)I.push(w());return I}}t([U],O.prototype,"readU8",null),t([U],O.prototype,"readU16",null),t([U],O.prototype,"readU32",null),t([U],O.prototype,"readU64",null),t([U],O.prototype,"readU128",null),t([U],O.prototype,"readU256",null),t([U],O.prototype,"readU512",null),t([U],O.prototype,"readString",null),t([U],O.prototype,"readFixedArray",null),t([U],O.prototype,"readArray",null),re.BinaryReader=O;function T(y){return y.charAt(0).toUpperCase()+y.slice(1)}function F(y,w,k,I,v){try{if(typeof I=="string")v[`write${T(I)}`](k);else if(I instanceof Array)if(typeof I[0]=="number"){if(k.length!==I[0])throw new E(`Expecting byte array of length ${I[0]}, but got ${k.length} bytes`);v.writeFixedArray(k)}else if(I.length===2&&typeof I[1]=="number"){if(k.length!==I[1])throw new E(`Expecting byte array of length ${I[1]}, but got ${k.length} bytes`);for(let m=0;m<I[1];m++)F(y,null,k[m],I[0],v)}else v.writeArray(k,m=>{F(y,w,m,I[0],v)});else if(I.kind!==void 0)switch(I.kind){case"option":{k==null?v.writeU8(0):(v.writeU8(1),F(y,w,k,I.type,v));break}case"map":{v.writeU32(k.size),k.forEach((m,A)=>{F(y,w,A,I.key,v),F(y,w,m,I.value,v)});break}default:throw new E(`FieldType ${I} unrecognized`)}else L(y,k,v)}catch(m){throw m instanceof E&&m.addToFieldPath(w),m}}function L(y,w,k){if(typeof w.borshSerialize=="function"){w.borshSerialize(k);return}const I=y.get(w.constructor);if(!I)throw new E(`Class ${w.constructor.name} is missing in schema`);if(I.kind==="struct")I.fields.map(([v,m])=>{F(y,v,w[v],m,k)});else if(I.kind==="enum"){const v=w[I.field];for(let m=0;m<I.values.length;++m){const[A,z]=I.values[m];if(A===v){k.writeU8(m),F(y,A,w[A],z,k);break}}}else throw new E(`Unexpected schema kind: ${I.kind} for ${w.constructor.name}`)}function $(y,w,k=B){const I=new k;return L(y,w,I),I.toArray()}re.serialize=$;function Z(y,w,k,I){try{if(typeof k=="string")return I[`read${T(k)}`]();if(k instanceof Array){if(typeof k[0]=="number")return I.readFixedArray(k[0]);if(typeof k[1]=="number"){const v=[];for(let m=0;m<k[1];m++)v.push(Z(y,null,k[0],I));return v}else return I.readArray(()=>Z(y,w,k[0],I))}if(k.kind==="option")return I.readU8()?Z(y,w,k.type,I):void 0;if(k.kind==="map"){let v=new Map;const m=I.readU32();for(let A=0;A<m;A++){const z=Z(y,w,k.key,I),K=Z(y,w,k.value,I);v.set(z,K)}return v}return H(y,k,I)}catch(v){throw v instanceof E&&v.addToFieldPath(w),v}}function H(y,w,k){if(typeof w.borshDeserialize=="function")return w.borshDeserialize(k);const I=y.get(w);if(!I)throw new E(`Class ${w.name} is missing in schema`);if(I.kind==="struct"){const v={};for(const[m,A]of y.get(w).fields)v[m]=Z(y,m,A,k);return new w(v)}if(I.kind==="enum"){const v=k.readU8();if(v>=I.values.length)throw new E(`Enum index: ${v} is out of range`);const[m,A]=I.values[v],z=Z(y,m,A,k);return new w({[m]:z})}throw new E(`Unexpected schema kind: ${I.kind} for ${w.constructor.name}`)}function te(y,w,k,I=O){const v=new I(k),m=H(y,w,v);if(v.offset<k.length)throw new E(`Unexpected ${k.length-v.offset} bytes after deserialized data`);return m}re.deserialize=te;function Q(y,w,k,I=O){const v=new I(k);return H(y,w,v)}return re.deserializeUnchecked=Q,re}var an=Qo(),S={},nr;function ei(){if(nr)return S;nr=1,Object.defineProperty(S,"__esModule",{value:!0}),S.s16=S.s8=S.nu64be=S.u48be=S.u40be=S.u32be=S.u24be=S.u16be=S.nu64=S.u48=S.u40=S.u32=S.u24=S.u16=S.u8=S.offset=S.greedy=S.Constant=S.UTF8=S.CString=S.Blob=S.Boolean=S.BitField=S.BitStructure=S.VariantLayout=S.Union=S.UnionLayoutDiscriminator=S.UnionDiscriminator=S.Structure=S.Sequence=S.DoubleBE=S.Double=S.FloatBE=S.Float=S.NearInt64BE=S.NearInt64=S.NearUInt64BE=S.NearUInt64=S.IntBE=S.Int=S.UIntBE=S.UInt=S.OffsetLayout=S.GreedyCount=S.ExternalLayout=S.bindConstructorLayout=S.nameWithProperty=S.Layout=S.uint8ArrayToBuffer=S.checkUint8Array=void 0,S.constant=S.utf8=S.cstr=S.blob=S.unionLayoutDiscriminator=S.union=S.seq=S.bits=S.struct=S.f64be=S.f64=S.f32be=S.f32=S.ns64be=S.s48be=S.s40be=S.s32be=S.s24be=S.s16be=S.ns64=S.s48=S.s40=S.s32=S.s24=void 0;const e=Rs();function n(p){if(!(p instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}S.checkUint8Array=n;function t(p){return n(p),e.Buffer.from(p.buffer,p.byteOffset,p.length)}S.uint8ArrayToBuffer=t;let r=class{constructor(a,u){if(!Number.isInteger(a))throw new TypeError("span must be an integer");this.span=a,this.property=u}makeDestinationObject(){return{}}getSpan(a,u){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(a){const u=Object.create(this.constructor.prototype);return Object.assign(u,this),u.property=a,u}fromArray(a){}};S.Layout=r;function s(p,a){return a.property?p+"["+a.property+"]":p}S.nameWithProperty=s;function o(p,a){if(typeof p!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(p,"layout_"))throw new Error("Class is already bound to a layout");if(!(a&&a instanceof r))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(a,"boundConstructor_"))throw new Error("layout is already bound to a constructor");p.layout_=a,a.boundConstructor_=p,a.makeDestinationObject=(()=>new p),Object.defineProperty(p.prototype,"encode",{value(u,l){return a.encode(this,u,l)},writable:!0}),Object.defineProperty(p,"decode",{value(u,l){return a.decode(u,l)},writable:!0})}S.bindConstructorLayout=o;class i extends r{isCount(){throw new Error("ExternalLayout is abstract")}}S.ExternalLayout=i;class f extends i{constructor(a=1,u){if(!Number.isInteger(a)||0>=a)throw new TypeError("elementSpan must be a (positive) integer");super(-1,u),this.elementSpan=a}isCount(){return!0}decode(a,u=0){n(a);const l=a.length-u;return Math.floor(l/this.elementSpan)}encode(a,u,l){return 0}}S.GreedyCount=f;class c extends i{constructor(a,u=0,l){if(!(a instanceof r))throw new TypeError("layout must be a Layout");if(!Number.isInteger(u))throw new TypeError("offset must be integer or undefined");super(a.span,l||a.property),this.layout=a,this.offset=u}isCount(){return this.layout instanceof h||this.layout instanceof b}decode(a,u=0){return this.layout.decode(a,u+this.offset)}encode(a,u,l=0){return this.layout.encode(a,u,l+this.offset)}}S.OffsetLayout=c;class h extends r{constructor(a,u){if(super(a,u),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,u=0){return t(a).readUIntLE(u,this.span)}encode(a,u,l=0){return t(u).writeUIntLE(a,l,this.span),this.span}}S.UInt=h;class b extends r{constructor(a,u){if(super(a,u),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,u=0){return t(a).readUIntBE(u,this.span)}encode(a,u,l=0){return t(u).writeUIntBE(a,l,this.span),this.span}}S.UIntBE=b;class R extends r{constructor(a,u){if(super(a,u),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,u=0){return t(a).readIntLE(u,this.span)}encode(a,u,l=0){return t(u).writeIntLE(a,l,this.span),this.span}}S.Int=R;class g extends r{constructor(a,u){if(super(a,u),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(a,u=0){return t(a).readIntBE(u,this.span)}encode(a,u,l=0){return t(u).writeIntBE(a,l,this.span),this.span}}S.IntBE=g;const E=Math.pow(2,32);function B(p){const a=Math.floor(p/E),u=p-a*E;return{hi32:a,lo32:u}}function U(p,a){return p*E+a}class O extends r{constructor(a){super(8,a)}decode(a,u=0){const l=t(a),_=l.readUInt32LE(u),C=l.readUInt32LE(u+4);return U(C,_)}encode(a,u,l=0){const _=B(a),C=t(u);return C.writeUInt32LE(_.lo32,l),C.writeUInt32LE(_.hi32,l+4),8}}S.NearUInt64=O;class T extends r{constructor(a){super(8,a)}decode(a,u=0){const l=t(a),_=l.readUInt32BE(u),C=l.readUInt32BE(u+4);return U(_,C)}encode(a,u,l=0){const _=B(a),C=t(u);return C.writeUInt32BE(_.hi32,l),C.writeUInt32BE(_.lo32,l+4),8}}S.NearUInt64BE=T;class F extends r{constructor(a){super(8,a)}decode(a,u=0){const l=t(a),_=l.readUInt32LE(u),C=l.readInt32LE(u+4);return U(C,_)}encode(a,u,l=0){const _=B(a),C=t(u);return C.writeUInt32LE(_.lo32,l),C.writeInt32LE(_.hi32,l+4),8}}S.NearInt64=F;class L extends r{constructor(a){super(8,a)}decode(a,u=0){const l=t(a),_=l.readInt32BE(u),C=l.readUInt32BE(u+4);return U(_,C)}encode(a,u,l=0){const _=B(a),C=t(u);return C.writeInt32BE(_.hi32,l),C.writeUInt32BE(_.lo32,l+4),8}}S.NearInt64BE=L;class $ extends r{constructor(a){super(4,a)}decode(a,u=0){return t(a).readFloatLE(u)}encode(a,u,l=0){return t(u).writeFloatLE(a,l),4}}S.Float=$;class Z extends r{constructor(a){super(4,a)}decode(a,u=0){return t(a).readFloatBE(u)}encode(a,u,l=0){return t(u).writeFloatBE(a,l),4}}S.FloatBE=Z;class H extends r{constructor(a){super(8,a)}decode(a,u=0){return t(a).readDoubleLE(u)}encode(a,u,l=0){return t(u).writeDoubleLE(a,l),8}}S.Double=H;class te extends r{constructor(a){super(8,a)}decode(a,u=0){return t(a).readDoubleBE(u)}encode(a,u,l=0){return t(u).writeDoubleBE(a,l),8}}S.DoubleBE=te;class Q extends r{constructor(a,u,l){if(!(a instanceof r))throw new TypeError("elementLayout must be a Layout");if(!(u instanceof i&&u.isCount()||Number.isInteger(u)&&0<=u))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let _=-1;!(u instanceof i)&&0<a.span&&(_=u*a.span),super(_,l),this.elementLayout=a,this.count=u}getSpan(a,u=0){if(0<=this.span)return this.span;let l=0,_=this.count;if(_ instanceof i&&(_=_.decode(a,u)),0<this.elementLayout.span)l=_*this.elementLayout.span;else{let C=0;for(;C<_;)l+=this.elementLayout.getSpan(a,u+l),++C}return l}decode(a,u=0){const l=[];let _=0,C=this.count;for(C instanceof i&&(C=C.decode(a,u));_<C;)l.push(this.elementLayout.decode(a,u)),u+=this.elementLayout.getSpan(a,u),_+=1;return l}encode(a,u,l=0){const _=this.elementLayout,C=a.reduce((W,X)=>W+_.encode(X,u,l+W),0);return this.count instanceof i&&this.count.encode(a.length,u,l),C}}S.Sequence=Q;class y extends r{constructor(a,u,l){if(!(Array.isArray(a)&&a.reduce((C,W)=>C&&W instanceof r,!0)))throw new TypeError("fields must be array of Layout instances");typeof u=="boolean"&&l===void 0&&(l=u,u=void 0);for(const C of a)if(0>C.span&&C.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let _=-1;try{_=a.reduce((C,W)=>C+W.getSpan(),0)}catch{}super(_,u),this.fields=a,this.decodePrefixes=!!l}getSpan(a,u=0){if(0<=this.span)return this.span;let l=0;try{l=this.fields.reduce((_,C)=>{const W=C.getSpan(a,u);return u+=W,_+W},0)}catch{throw new RangeError("indeterminate span")}return l}decode(a,u=0){n(a);const l=this.makeDestinationObject();for(const _ of this.fields)if(_.property!==void 0&&(l[_.property]=_.decode(a,u)),u+=_.getSpan(a,u),this.decodePrefixes&&a.length===u)break;return l}encode(a,u,l=0){const _=l;let C=0,W=0;for(const X of this.fields){let oe=X.span;if(W=0<oe?oe:0,X.property!==void 0){const Pe=a[X.property];Pe!==void 0&&(W=X.encode(Pe,u,l),0>oe&&(oe=X.getSpan(u,l)))}C=l,l+=oe}return C+W-_}fromArray(a){const u=this.makeDestinationObject();for(const l of this.fields)l.property!==void 0&&0<a.length&&(u[l.property]=a.shift());return u}layoutFor(a){if(typeof a!="string")throw new TypeError("property must be string");for(const u of this.fields)if(u.property===a)return u}offsetOf(a){if(typeof a!="string")throw new TypeError("property must be string");let u=0;for(const l of this.fields){if(l.property===a)return u;0>l.span?u=-1:0<=u&&(u+=l.span)}}}S.Structure=y;class w{constructor(a){this.property=a}decode(a,u){throw new Error("UnionDiscriminator is abstract")}encode(a,u,l){throw new Error("UnionDiscriminator is abstract")}}S.UnionDiscriminator=w;class k extends w{constructor(a,u){if(!(a instanceof i&&a.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(u||a.property||"variant"),this.layout=a}decode(a,u){return this.layout.decode(a,u)}encode(a,u,l){return this.layout.encode(a,u,l)}}S.UnionLayoutDiscriminator=k;class I extends r{constructor(a,u,l){let _;if(a instanceof h||a instanceof b)_=new k(new c(a));else if(a instanceof i&&a.isCount())_=new k(a);else if(a instanceof w)_=a;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(u===void 0&&(u=null),!(u===null||u instanceof r))throw new TypeError("defaultLayout must be null or a Layout");if(u!==null){if(0>u.span)throw new Error("defaultLayout must have constant span");u.property===void 0&&(u=u.replicate("content"))}let C=-1;u&&(C=u.span,0<=C&&(a instanceof h||a instanceof b)&&(C+=_.layout.span)),super(C,l),this.discriminator=_,this.usesPrefixDiscriminator=a instanceof h||a instanceof b,this.defaultLayout=u,this.registry={};let W=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(X){return W(X)},this.configGetSourceVariant=function(X){W=X.bind(this)}}getSpan(a,u=0){if(0<=this.span)return this.span;const l=this.getVariant(a,u);if(!l)throw new Error("unable to determine span for unrecognized variant");return l.getSpan(a,u)}defaultGetSourceVariant(a){if(Object.prototype.hasOwnProperty.call(a,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(a,this.defaultLayout.property))return;const u=this.registry[a[this.discriminator.property]];if(u&&(!u.layout||u.property&&Object.prototype.hasOwnProperty.call(a,u.property)))return u}else for(const u in this.registry){const l=this.registry[u];if(l.property&&Object.prototype.hasOwnProperty.call(a,l.property))return l}throw new Error("unable to infer src variant")}decode(a,u=0){let l;const _=this.discriminator,C=_.decode(a,u),W=this.registry[C];if(W===void 0){const X=this.defaultLayout;let oe=0;this.usesPrefixDiscriminator&&(oe=_.layout.span),l=this.makeDestinationObject(),l[_.property]=C,l[X.property]=X.decode(a,u+oe)}else l=W.decode(a,u);return l}encode(a,u,l=0){const _=this.getSourceVariant(a);if(_===void 0){const C=this.discriminator,W=this.defaultLayout;let X=0;return this.usesPrefixDiscriminator&&(X=C.layout.span),C.encode(a[C.property],u,l),X+W.encode(a[W.property],u,l+X)}return _.encode(a,u,l)}addVariant(a,u,l){const _=new v(this,a,u,l);return this.registry[a]=_,_}getVariant(a,u=0){let l;return a instanceof Uint8Array?l=this.discriminator.decode(a,u):l=a,this.registry[l]}}S.Union=I;class v extends r{constructor(a,u,l,_){if(!(a instanceof I))throw new TypeError("union must be a Union");if(!Number.isInteger(u)||0>u)throw new TypeError("variant must be a (non-negative) integer");if(typeof l=="string"&&_===void 0&&(_=l,l=null),l){if(!(l instanceof r))throw new TypeError("layout must be a Layout");if(a.defaultLayout!==null&&0<=l.span&&l.span>a.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof _!="string")throw new TypeError("variant must have a String property")}let C=a.span;0>a.span&&(C=l?l.span:0,0<=C&&a.usesPrefixDiscriminator&&(C+=a.discriminator.layout.span)),super(C,_),this.union=a,this.variant=u,this.layout=l||null}getSpan(a,u=0){if(0<=this.span)return this.span;let l=0;this.union.usesPrefixDiscriminator&&(l=this.union.discriminator.layout.span);let _=0;return this.layout&&(_=this.layout.getSpan(a,u+l)),l+_}decode(a,u=0){const l=this.makeDestinationObject();if(this!==this.union.getVariant(a,u))throw new Error("variant mismatch");let _=0;return this.union.usesPrefixDiscriminator&&(_=this.union.discriminator.layout.span),this.layout?l[this.property]=this.layout.decode(a,u+_):this.property?l[this.property]=!0:this.union.usesPrefixDiscriminator&&(l[this.union.discriminator.property]=this.variant),l}encode(a,u,l=0){let _=0;if(this.union.usesPrefixDiscriminator&&(_=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(a,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,u,l);let C=_;if(this.layout&&(this.layout.encode(a[this.property],u,l+_),C+=this.layout.getSpan(u,l+_),0<=this.union.span&&C>this.union.span))throw new Error("encoded variant overruns containing union");return C}fromArray(a){if(this.layout)return this.layout.fromArray(a)}}S.VariantLayout=v;function m(p){return 0>p&&(p+=4294967296),p}class A extends r{constructor(a,u,l){if(!(a instanceof h||a instanceof b))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof u=="string"&&l===void 0&&(l=u,u=!1),4<a.span)throw new RangeError("word cannot exceed 32 bits");super(a.span,l),this.word=a,this.msb=!!u,this.fields=[];let _=0;this._packedSetValue=function(C){return _=m(C),this},this._packedGetValue=function(){return _}}decode(a,u=0){const l=this.makeDestinationObject(),_=this.word.decode(a,u);this._packedSetValue(_);for(const C of this.fields)C.property!==void 0&&(l[C.property]=C.decode(a));return l}encode(a,u,l=0){const _=this.word.decode(u,l);this._packedSetValue(_);for(const C of this.fields)if(C.property!==void 0){const W=a[C.property];W!==void 0&&C.encode(W)}return this.word.encode(this._packedGetValue(),u,l)}addField(a,u){const l=new z(this,a,u);return this.fields.push(l),l}addBoolean(a){const u=new K(this,a);return this.fields.push(u),u}fieldFor(a){if(typeof a!="string")throw new TypeError("property must be string");for(const u of this.fields)if(u.property===a)return u}}S.BitStructure=A;class z{constructor(a,u,l){if(!(a instanceof A))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(u)||0>=u)throw new TypeError("bits must be positive integer");const _=8*a.span,C=a.fields.reduce((W,X)=>W+X.bits,0);if(u+C>_)throw new Error("bits too long for span remainder ("+(_-C)+" of "+_+" remain)");this.container=a,this.bits=u,this.valueMask=(1<<u)-1,u===32&&(this.valueMask=4294967295),this.start=C,this.container.msb&&(this.start=_-C-u),this.wordMask=m(this.valueMask<<this.start),this.property=l}decode(a,u){const l=this.container._packedGetValue();return m(l&this.wordMask)>>>this.start}encode(a){if(typeof a!="number"||!Number.isInteger(a)||a!==m(a&this.valueMask))throw new TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const u=this.container._packedGetValue(),l=m(a<<this.start);this.container._packedSetValue(m(u&~this.wordMask)|l)}}S.BitField=z;class K extends z{constructor(a,u){super(a,1,u)}decode(a,u){return!!super.decode(a,u)}encode(a){typeof a=="boolean"&&(a=+a),super.encode(a)}}S.Boolean=K;class j extends r{constructor(a,u){if(!(a instanceof i&&a.isCount()||Number.isInteger(a)&&0<=a))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let l=-1;a instanceof i||(l=a),super(l,u),this.length=a}getSpan(a,u){let l=this.span;return 0>l&&(l=this.length.decode(a,u)),l}decode(a,u=0){let l=this.span;return 0>l&&(l=this.length.decode(a,u)),t(a).slice(u,u+l)}encode(a,u,l){let _=this.length;if(this.length instanceof i&&(_=a.length),!(a instanceof Uint8Array&&_===a.length))throw new TypeError(s("Blob.encode",this)+" requires (length "+_+") Uint8Array as src");if(l+_>u.length)throw new RangeError("encoding overruns Uint8Array");const C=t(a);return t(u).write(C.toString("hex"),l,_,"hex"),this.length instanceof i&&this.length.encode(_,u,l),_}}S.Blob=j;class P extends r{constructor(a){super(-1,a)}getSpan(a,u=0){n(a);let l=u;for(;l<a.length&&a[l]!==0;)l+=1;return 1+l-u}decode(a,u=0){const l=this.getSpan(a,u);return t(a).slice(u,u+l-1).toString("utf-8")}encode(a,u,l=0){typeof a!="string"&&(a=String(a));const _=e.Buffer.from(a,"utf8"),C=_.length;if(l+C>u.length)throw new RangeError("encoding overruns Buffer");const W=t(u);return _.copy(W,l),W[l+C]=0,C+1}}S.CString=P;class V extends r{constructor(a,u){if(typeof a=="string"&&u===void 0&&(u=a,a=void 0),a===void 0)a=-1;else if(!Number.isInteger(a))throw new TypeError("maxSpan must be an integer");super(-1,u),this.maxSpan=a}getSpan(a,u=0){return n(a),a.length-u}decode(a,u=0){const l=this.getSpan(a,u);if(0<=this.maxSpan&&this.maxSpan<l)throw new RangeError("text length exceeds maxSpan");return t(a).slice(u,u+l).toString("utf-8")}encode(a,u,l=0){typeof a!="string"&&(a=String(a));const _=e.Buffer.from(a,"utf8"),C=_.length;if(0<=this.maxSpan&&this.maxSpan<C)throw new RangeError("text length exceeds maxSpan");if(l+C>u.length)throw new RangeError("encoding overruns Buffer");return _.copy(t(u),l),C}}S.UTF8=V;class G extends r{constructor(a,u){super(0,u),this.value=a}decode(a,u){return this.value}encode(a,u,l){return 0}}return S.Constant=G,S.greedy=((p,a)=>new f(p,a)),S.offset=((p,a,u)=>new c(p,a,u)),S.u8=(p=>new h(1,p)),S.u16=(p=>new h(2,p)),S.u24=(p=>new h(3,p)),S.u32=(p=>new h(4,p)),S.u40=(p=>new h(5,p)),S.u48=(p=>new h(6,p)),S.nu64=(p=>new O(p)),S.u16be=(p=>new b(2,p)),S.u24be=(p=>new b(3,p)),S.u32be=(p=>new b(4,p)),S.u40be=(p=>new b(5,p)),S.u48be=(p=>new b(6,p)),S.nu64be=(p=>new T(p)),S.s8=(p=>new R(1,p)),S.s16=(p=>new R(2,p)),S.s24=(p=>new R(3,p)),S.s32=(p=>new R(4,p)),S.s40=(p=>new R(5,p)),S.s48=(p=>new R(6,p)),S.ns64=(p=>new F(p)),S.s16be=(p=>new g(2,p)),S.s24be=(p=>new g(3,p)),S.s32be=(p=>new g(4,p)),S.s40be=(p=>new g(5,p)),S.s48be=(p=>new g(6,p)),S.ns64be=(p=>new L(p)),S.f32=(p=>new $(p)),S.f32be=(p=>new Z(p)),S.f64=(p=>new H(p)),S.f64be=(p=>new te(p)),S.struct=((p,a,u)=>new y(p,a,u)),S.bits=((p,a,u)=>new A(p,a,u)),S.seq=((p,a,u)=>new Q(p,a,u)),S.union=((p,a,u)=>new I(p,a,u)),S.unionLayoutDiscriminator=((p,a)=>new k(p,a)),S.blob=((p,a)=>new j(p,a)),S.cstr=(p=>new P(p)),S.utf8=((p,a)=>new V(p,a)),S.constant=((p,a)=>new G(p,a)),S}var d=ei(),ti=8078e3,ni=8078001,ri=8078004,si=8078005,oi=8078006,ii=8078011;function Pr(e){return Array.isArray(e)?"%5B"+e.map(Pr).join("%2C%20")+"%5D":typeof e=="bigint"?`${e}n`:encodeURIComponent(String(e!=null&&Object.getPrototypeOf(e)===null?{...e}:e))}function ai([e,n]){return`${e}=${Pr(n)}`}function ci(e){const n=Object.entries(e).map(ai).join("&");return btoa(n)}function ui(e,n={}){{let t=`Solana error #${e}; Decode this error by running \`npx @solana/errors decode -- ${e}`;return Object.keys(n).length&&(t+=` '${ci(n)}'`),`${t}\``}}var rt=class extends Error{constructor(...[n,t]){let r,s;if(t){const{cause:i,...f}=t;i&&(s={cause:i}),Object.keys(f).length>0&&(r=f)}const o=ui(n,r);super(o,s);$t(this,"cause",this.cause);$t(this,"context");this.context={__code:n,...r},this.name="SolanaError"}};function fi(e,n){return"fixedSize"in n?n.fixedSize:n.getSizeFromValue(e)}function di(e){return Object.freeze({...e,encode:n=>{const t=new Uint8Array(fi(n,e));return e.write(n,t,0),t}})}function li(e){return Object.freeze({...e,decode:(n,t=0)=>e.read(n,t)[0]})}function Je(e){return"fixedSize"in e&&typeof e.fixedSize=="number"}function hi(e,n){if(Je(e)!==Je(n))throw new rt(ri);if(Je(e)&&Je(n)&&e.fixedSize!==n.fixedSize)throw new rt(si,{decoderFixedSize:n.fixedSize,encoderFixedSize:e.fixedSize});if(!Je(e)&&!Je(n)&&e.maxSize!==n.maxSize)throw new rt(oi,{decoderMaxSize:n.maxSize,encoderMaxSize:e.maxSize});return{...n,...e,decode:n.decode,encode:e.encode,read:n.read,write:e.write}}function pi(e,n,t=0){if(n.length-t<=0)throw new rt(ti,{codecDescription:e})}function yi(e,n,t,r=0){const s=t.length-r;if(s<n)throw new rt(ni,{bytesLength:s,codecDescription:e,expected:n})}function gi(e,n,t,r){if(r<n||r>t)throw new rt(ii,{codecDescription:e,max:t,min:n,value:r})}function Vr(e){return(e==null?void 0:e.endian)!==1}function wi(e){return di({fixedSize:e.size,write(n,t,r){e.range&&gi(e.name,e.range[0],e.range[1],n);const s=new ArrayBuffer(e.size);return e.set(new DataView(s),n,Vr(e.config)),t.set(new Uint8Array(s),r),r+e.size}})}function mi(e){return li({fixedSize:e.size,read(n,t=0){pi(e.name,n,t),yi(e.name,e.size,n,t);const r=new DataView(bi(n,t,e.size));return[e.get(r,Vr(e.config)),t+e.size]}})}function bi(e,n,t){const r=e.byteOffset+(n??0),s=t??e.byteLength;return e.buffer.slice(r,r+s)}var Ei=(e={})=>wi({config:e,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(n,t,r)=>n.setBigUint64(0,BigInt(t),r),size:8}),vi=(e={})=>mi({config:e,get:(n,t)=>n.getBigUint64(0,t),name:"u64",size:8}),xi=(e={})=>hi(Ei(e),vi(e));class Si extends TypeError{constructor(n,t){let r;const{message:s,explanation:o,...i}=n,{path:f}=n,c=f.length===0?s:`At path: ${f.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>r??(r=[n,...t()])}}function Ai(e){return wt(e)&&typeof e[Symbol.iterator]=="function"}function wt(e){return typeof e=="object"&&e!=null}function Ut(e){return wt(e)&&!Array.isArray(e)}function Be(e){return typeof e=="symbol"?e.toString():typeof e=="string"?JSON.stringify(e):`${e}`}function Bi(e){const{done:n,value:t}=e.next();return n?void 0:t}function Ii(e,n,t,r){if(e===!0)return;e===!1?e={}:typeof e=="string"&&(e={message:e});const{path:s,branch:o}=n,{type:i}=t,{refinement:f,message:c=`Expected a value of type \`${i}\`${f?` with refinement \`${f}\``:""}, but received: \`${Be(r)}\``}=e;return{value:r,type:i,refinement:f,key:s[s.length-1],path:s,branch:o,...e,message:c}}function*rr(e,n,t,r){Ai(e)||(e=[e]);for(const s of e){const o=Ii(s,n,t,r);o&&(yield o)}}function*Rn(e,n,t={}){const{path:r=[],branch:s=[e],coerce:o=!1,mask:i=!1}=t,f={path:r,branch:s,mask:i};o&&(e=n.coercer(e,f));let c="valid";for(const h of n.validator(e,f))h.explanation=t.message,c="not_valid",yield[h,void 0];for(let[h,b,R]of n.entries(e,f)){const g=Rn(b,R,{path:h===void 0?r:[...r,h],branch:h===void 0?s:[...s,b],coerce:o,mask:i,message:t.message});for(const E of g)E[0]?(c=E[0].refinement!=null?"not_refined":"not_valid",yield[E[0],void 0]):o&&(b=E[1],h===void 0?e=b:e instanceof Map?e.set(h,b):e instanceof Set?e.add(b):wt(e)&&(b!==void 0||h in e)&&(e[h]=b))}if(c!=="not_valid")for(const h of n.refiner(e,f))h.explanation=t.message,c="not_refined",yield[h,void 0];c==="valid"&&(yield[void 0,e])}let Le=class{constructor(n){const{type:t,schema:r,validator:s,refiner:o,coercer:i=c=>c,entries:f=function*(){}}=n;this.type=t,this.schema=r,this.entries=f,this.coercer=i,s?this.validator=(c,h)=>{const b=s(c,h);return rr(b,h,this,c)}:this.validator=()=>[],o?this.refiner=(c,h)=>{const b=o(c,h);return rr(b,h,this,c)}:this.refiner=()=>[]}assert(n,t){return Ri(n,this,t)}create(n,t){return ht(n,this,t)}is(n){return jr(n,this)}mask(n,t){return ki(n,this,t)}validate(n,t={}){return mt(n,this,t)}};function Ri(e,n,t){const r=mt(e,n,{message:t});if(r[0])throw r[0]}function ht(e,n,t){const r=mt(e,n,{coerce:!0,message:t});if(r[0])throw r[0];return r[1]}function ki(e,n,t){const r=mt(e,n,{coerce:!0,mask:!0,message:t});if(r[0])throw r[0];return r[1]}function jr(e,n){return!mt(e,n)[0]}function mt(e,n,t={}){const r=Rn(e,n,t),s=Bi(r);return s[0]?[new Si(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function He(e,n){return new Le({type:e,schema:null,validator:n})}function _i(){return He("any",()=>!0)}function q(e){return new Le({type:"array",schema:e,*entries(n){if(e&&Array.isArray(n))for(const[t,r]of n.entries())yield[t,r,e]},coercer(n){return Array.isArray(n)?n.slice():n},validator(n){return Array.isArray(n)||`Expected an array value, but received: ${Be(n)}`}})}function Ue(){return He("boolean",e=>typeof e=="boolean")}function kn(e){return He("instance",n=>n instanceof e||`Expected a \`${e.name}\` instance, but received: ${Be(n)}`)}function ie(e){const n=Be(e),t=typeof e;return new Le({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?e:null,validator(r){return r===e||`Expected the literal \`${n}\`, but received: ${Be(r)}`}})}function Oi(){return He("never",()=>!1)}function M(e){return new Le({...e,validator:(n,t)=>n===null||e.validator(n,t),refiner:(n,t)=>n===null||e.refiner(n,t)})}function x(){return He("number",e=>typeof e=="number"&&!isNaN(e)||`Expected a number, but received: ${Be(e)}`)}function Y(e){return new Le({...e,validator:(n,t)=>n===void 0||e.validator(n,t),refiner:(n,t)=>n===void 0||e.refiner(n,t)})}function $r(e,n){return new Le({type:"record",schema:null,*entries(t){if(wt(t))for(const r in t){const s=t[r];yield[r,r,e],yield[r,s,n]}},validator(t){return Ut(t)||`Expected an object, but received: ${Be(t)}`},coercer(t){return Ut(t)?{...t}:t}})}function D(){return He("string",e=>typeof e=="string"||`Expected a string, but received: ${Be(e)}`)}function _n(e){const n=Oi();return new Le({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(e.length,t.length);for(let s=0;s<r;s++)yield[s,t[s],e[s]||n]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Be(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function N(e){const n=Object.keys(e);return new Le({type:"type",schema:e,*entries(t){if(wt(t))for(const r of n)yield[r,t[r],e[r]]},validator(t){return Ut(t)||`Expected an object, but received: ${Be(t)}`},coercer(t){return Ut(t)?{...t}:t}})}function me(e){const n=e.map(t=>t.type).join(" | ");return new Le({type:"union",schema:null,coercer(t,r){for(const s of e){const[o,i]=s.validate(t,{coerce:!0,mask:r.mask});if(!o)return i}return t},validator(t,r){const s=[];for(const o of e){const[...i]=Rn(t,o,r),[f]=i;if(f[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${n}\`, but received: ${Be(t)}`,...s]}})}function ct(){return He("unknown",()=>!0)}function bt(e,n,t){return new Le({...e,coercer:(r,s)=>jr(r,n)?e.coercer(t(r,s),s):e.coercer(r,s)})}const Zr=pr(so);var cn,sr;function Ti(){if(sr)return cn;sr=1;const e=Zr.v4;return cn=function(t,r,s,o){if(typeof t!="string")throw new TypeError(t+" must be a string");o=o||{};const i=typeof o.version=="number"?o.version:2;if(i!==1&&i!==2)throw new TypeError(i+" must be 1 or 2");const f={method:t};if(i===2&&(f.jsonrpc="2.0"),r){if(typeof r!="object"&&!Array.isArray(r))throw new TypeError(r+" must be an object, array or omitted");f.params=r}if(typeof s>"u"){const c=typeof o.generator=="function"?o.generator:function(){return e()};f.id=c(f,o)}else i===2&&s===null?o.notificationIdNull&&(f.id=null):f.id=s;return f},cn}var un,or;function Ui(){if(or)return un;or=1;const e=Zr.v4,n=Ti(),t=function(r,s){if(!(this instanceof t))return new t(r,s);s||(s={}),this.options={reviver:typeof s.reviver<"u"?s.reviver:null,replacer:typeof s.replacer<"u"?s.replacer:null,generator:typeof s.generator<"u"?s.generator:function(){return e()},version:typeof s.version<"u"?s.version:2,notificationIdNull:typeof s.notificationIdNull=="boolean"?s.notificationIdNull:!1},this.callServer=r};return un=t,t.prototype.request=function(r,s,o,i){const f=this;let c=null;const h=Array.isArray(r)&&typeof s=="function";if(this.options.version===1&&h)throw new TypeError("JSON-RPC 1.0 does not support batching");if(h||!h&&r&&typeof r=="object"&&typeof s=="function")i=s,c=r;else{typeof o=="function"&&(i=o,o=void 0);const g=typeof i=="function";try{c=n(r,s,o,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(E){if(g){i(E);return}throw E}if(!g)return c}let R;try{R=JSON.stringify(c,this.options.replacer)}catch(g){i(g);return}return this.callServer(R,function(g,E){f._parseResponse(g,E,i)}),c},t.prototype._parseResponse=function(r,s,o){if(r){o(r);return}if(!s){o();return}let i;try{i=JSON.parse(s,this.options.reviver)}catch(f){o(f);return}if(o.length===3)if(Array.isArray(i)){const f=function(h){return typeof h.error<"u"},c=function(h){return!f(h)};o(null,i.filter(f),i.filter(c));return}else{o(null,i.error,i.result);return}o(null,i)},un}Ui();var fn={exports:{}},ir;function Li(){return ir||(ir=1,(function(e){var n=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,h,b){this.fn=c,this.context=h,this.once=b||!1}function o(c,h,b,R,g){if(typeof b!="function")throw new TypeError("The listener must be a function");var E=new s(b,R||c,g),B=t?t+h:h;return c._events[B]?c._events[B].fn?c._events[B]=[c._events[B],E]:c._events[B].push(E):(c._events[B]=E,c._eventsCount++),c}function i(c,h){--c._eventsCount===0?c._events=new r:delete c._events[h]}function f(){this._events=new r,this._eventsCount=0}f.prototype.eventNames=function(){var h=[],b,R;if(this._eventsCount===0)return h;for(R in b=this._events)n.call(b,R)&&h.push(t?R.slice(1):R);return Object.getOwnPropertySymbols?h.concat(Object.getOwnPropertySymbols(b)):h},f.prototype.listeners=function(h){var b=t?t+h:h,R=this._events[b];if(!R)return[];if(R.fn)return[R.fn];for(var g=0,E=R.length,B=new Array(E);g<E;g++)B[g]=R[g].fn;return B},f.prototype.listenerCount=function(h){var b=t?t+h:h,R=this._events[b];return R?R.fn?1:R.length:0},f.prototype.emit=function(h,b,R,g,E,B){var U=t?t+h:h;if(!this._events[U])return!1;var O=this._events[U],T=arguments.length,F,L;if(O.fn){switch(O.once&&this.removeListener(h,O.fn,void 0,!0),T){case 1:return O.fn.call(O.context),!0;case 2:return O.fn.call(O.context,b),!0;case 3:return O.fn.call(O.context,b,R),!0;case 4:return O.fn.call(O.context,b,R,g),!0;case 5:return O.fn.call(O.context,b,R,g,E),!0;case 6:return O.fn.call(O.context,b,R,g,E,B),!0}for(L=1,F=new Array(T-1);L<T;L++)F[L-1]=arguments[L];O.fn.apply(O.context,F)}else{var $=O.length,Z;for(L=0;L<$;L++)switch(O[L].once&&this.removeListener(h,O[L].fn,void 0,!0),T){case 1:O[L].fn.call(O[L].context);break;case 2:O[L].fn.call(O[L].context,b);break;case 3:O[L].fn.call(O[L].context,b,R);break;case 4:O[L].fn.call(O[L].context,b,R,g);break;default:if(!F)for(Z=1,F=new Array(T-1);Z<T;Z++)F[Z-1]=arguments[Z];O[L].fn.apply(O[L].context,F)}}return!0},f.prototype.on=function(h,b,R){return o(this,h,b,R,!1)},f.prototype.once=function(h,b,R){return o(this,h,b,R,!0)},f.prototype.removeListener=function(h,b,R,g){var E=t?t+h:h;if(!this._events[E])return this;if(!b)return i(this,E),this;var B=this._events[E];if(B.fn)B.fn===b&&(!g||B.once)&&(!R||B.context===R)&&i(this,E);else{for(var U=0,O=[],T=B.length;U<T;U++)(B[U].fn!==b||g&&!B[U].once||R&&B[U].context!==R)&&O.push(B[U]);O.length?this._events[E]=O.length===1?O[0]:O:i(this,E)}return this},f.prototype.removeAllListeners=function(h){var b;return h?(b=t?t+h:h,this._events[b]&&i(this,b)):(this._events=new r,this._eventsCount=0),this},f.prototype.off=f.prototype.removeListener,f.prototype.addListener=f.prototype.on,f.prefixed=t,f.EventEmitter=f,e.exports=f})(fn)),fn.exports}Li();/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ar=(e,n)=>(e+(e>=0?n:-n)/Yr)/n;function Ci(e,n,t){const[[r,s],[o,i]]=n,f=ar(i*e,t),c=ar(-s*e,t);let h=e-f*r-c*o,b=-f*s-c*i;const R=h<Fe,g=b<Fe;R&&(h=-h),g&&(b=-b);const E=pt(Math.ceil(Sr(t)/2))+st;if(h<Fe||h>=E||b<Fe||b>=E)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:R,k1:h,k2neg:g,k2:b}}function yn(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function dn(e,n){const t={};for(let r of Object.keys(n))t[r]=e[r]===void 0?n[r]:e[r];return Ye(t.lowS,"lowS"),Ye(t.prehash,"prehash"),t.format!==void 0&&yn(t.format),t}class Ni extends Error{constructor(n=""){super(n)}}const Ce={Err:Ni,_tlv:{encode:(e,n)=>{const{Err:t}=Ce;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,s=Et(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=r>127?Et(s.length/2|128):"";return Et(e)+o+s+n},decode(e,n){const{Err:t}=Ce;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const s=n[r++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const h=n.subarray(r,r+c);if(h.length!==c)throw new t("tlv.decode: length bytes not complete");if(h[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const b of h)i=i<<8|b;if(r+=c,i<128)throw new t("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+i);if(f.length!==i)throw new t("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+i)}}},_int:{encode(e){const{Err:n}=Ce;if(e<Fe)throw new n("integer: negative integers are not allowed");let t=Et(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=Ce;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return qt(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=Ce,s=ce("signature",e),{v:o,l:i}=r.decode(48,s);if(i.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:c}=r.decode(2,o),{v:h,l:b}=r.decode(2,c);if(b.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(h)}},hexFromSig(e){const{_tlv:n,_int:t}=Ce,r=n.encode(2,t.encode(e.r)),s=n.encode(2,t.encode(e.s)),o=r+s;return n.encode(48,o)}},Fe=BigInt(0),st=BigInt(1),Yr=BigInt(2),vt=BigInt(3),zi=BigInt(4);function et(e,n){const{BYTES:t}=e;let r;if(typeof n=="bigint")r=n;else{let s=ce("private key",n);try{r=e.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof n}`)}}if(!e.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function Fi(e,n={}){const t=Kr("weierstrass",e,n),{Fp:r,Fn:s}=t;let o=t.CURVE;const{h:i,n:f}=o;yt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=n;if(c&&(!r.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const h=Hr(r,s);function b(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function R(I,v,m){const{x:A,y:z}=v.toAffine(),K=r.toBytes(A);if(Ye(m,"isCompressed"),m){b();const j=!r.isOdd(z);return Oe(Gr(j),K)}else return Oe(Uint8Array.of(4),K,r.toBytes(z))}function g(I){Ae(I,void 0,"Point");const{publicKey:v,publicKeyUncompressed:m}=h,A=I.length,z=I[0],K=I.subarray(1);if(A===v&&(z===2||z===3)){const j=r.fromBytes(K);if(!r.isValid(j))throw new Error("bad point: is not on curve, wrong x");const P=U(j);let V;try{V=r.sqrt(P)}catch(a){const u=a instanceof Error?": "+a.message:"";throw new Error("bad point: is not on curve, sqrt error"+u)}b();const G=r.isOdd(V);return(z&1)===1!==G&&(V=r.neg(V)),{x:j,y:V}}else if(A===m&&z===4){const j=r.BYTES,P=r.fromBytes(K.subarray(0,j)),V=r.fromBytes(K.subarray(j,j*2));if(!O(P,V))throw new Error("bad point: is not on curve");return{x:P,y:V}}else throw new Error(`bad point: got length ${A}, expected compressed=${v} or uncompressed=${m}`)}const E=n.toBytes||R,B=n.fromBytes||g;function U(I){const v=r.sqr(I),m=r.mul(v,I);return r.add(r.add(m,r.mul(I,o.a)),o.b)}function O(I,v){const m=r.sqr(v),A=U(I);return r.eql(m,A)}if(!O(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const T=r.mul(r.pow(o.a,vt),zi),F=r.mul(r.sqr(o.b),BigInt(27));if(r.is0(r.add(T,F)))throw new Error("bad curve params: a or b");function L(I,v,m=!1){if(!r.isValid(v)||m&&r.is0(v))throw new Error(`bad point coordinate ${I}`);return v}function $(I){if(!(I instanceof y))throw new Error("ProjectivePoint expected")}function Z(I){if(!c||!c.basises)throw new Error("no endo");return Ci(I,c.basises,s.ORDER)}const H=It((I,v)=>{const{X:m,Y:A,Z:z}=I;if(r.eql(z,r.ONE))return{x:m,y:A};const K=I.is0();v==null&&(v=K?r.ONE:r.inv(z));const j=r.mul(m,v),P=r.mul(A,v),V=r.mul(z,v);if(K)return{x:r.ZERO,y:r.ZERO};if(!r.eql(V,r.ONE))throw new Error("invZ was invalid");return{x:j,y:P}}),te=It(I=>{if(I.is0()){if(n.allowInfinityPoint&&!r.is0(I.Y))return;throw new Error("bad point: ZERO")}const{x:v,y:m}=I.toAffine();if(!r.isValid(v)||!r.isValid(m))throw new Error("bad point: x or y not field elements");if(!O(v,m))throw new Error("bad point: equation left != right");if(!I.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Q(I,v,m,A,z){return m=new y(r.mul(m.X,I),m.Y,m.Z),v=Rt(A,v),m=Rt(z,m),v.add(m)}class y{constructor(v,m,A){this.X=L("x",v),this.Y=L("y",m,!0),this.Z=L("z",A),Object.freeze(this)}static CURVE(){return o}static fromAffine(v){const{x:m,y:A}=v||{};if(!v||!r.isValid(m)||!r.isValid(A))throw new Error("invalid affine point");if(v instanceof y)throw new Error("projective point not allowed");return r.is0(m)&&r.is0(A)?y.ZERO:new y(m,A,r.ONE)}static fromBytes(v){const m=y.fromAffine(B(Ae(v,void 0,"point")));return m.assertValidity(),m}static fromHex(v){return y.fromBytes(ce("pointHex",v))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,m=!0){return k.createCache(this,v),m||this.multiply(vt),this}assertValidity(){te(this)}hasEvenY(){const{y:v}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(v)}equals(v){$(v);const{X:m,Y:A,Z:z}=this,{X:K,Y:j,Z:P}=v,V=r.eql(r.mul(m,P),r.mul(K,z)),G=r.eql(r.mul(A,P),r.mul(j,z));return V&&G}negate(){return new y(this.X,r.neg(this.Y),this.Z)}double(){const{a:v,b:m}=o,A=r.mul(m,vt),{X:z,Y:K,Z:j}=this;let P=r.ZERO,V=r.ZERO,G=r.ZERO,p=r.mul(z,z),a=r.mul(K,K),u=r.mul(j,j),l=r.mul(z,K);return l=r.add(l,l),G=r.mul(z,j),G=r.add(G,G),P=r.mul(v,G),V=r.mul(A,u),V=r.add(P,V),P=r.sub(a,V),V=r.add(a,V),V=r.mul(P,V),P=r.mul(l,P),G=r.mul(A,G),u=r.mul(v,u),l=r.sub(p,u),l=r.mul(v,l),l=r.add(l,G),G=r.add(p,p),p=r.add(G,p),p=r.add(p,u),p=r.mul(p,l),V=r.add(V,p),u=r.mul(K,j),u=r.add(u,u),p=r.mul(u,l),P=r.sub(P,p),G=r.mul(u,a),G=r.add(G,G),G=r.add(G,G),new y(P,V,G)}add(v){$(v);const{X:m,Y:A,Z:z}=this,{X:K,Y:j,Z:P}=v;let V=r.ZERO,G=r.ZERO,p=r.ZERO;const a=o.a,u=r.mul(o.b,vt);let l=r.mul(m,K),_=r.mul(A,j),C=r.mul(z,P),W=r.add(m,A),X=r.add(K,j);W=r.mul(W,X),X=r.add(l,_),W=r.sub(W,X),X=r.add(m,z);let oe=r.add(K,P);return X=r.mul(X,oe),oe=r.add(l,C),X=r.sub(X,oe),oe=r.add(A,z),V=r.add(j,P),oe=r.mul(oe,V),V=r.add(_,C),oe=r.sub(oe,V),p=r.mul(a,X),V=r.mul(u,C),p=r.add(V,p),V=r.sub(_,p),p=r.add(_,p),G=r.mul(V,p),_=r.add(l,l),_=r.add(_,l),C=r.mul(a,C),X=r.mul(u,X),_=r.add(_,C),C=r.sub(l,C),C=r.mul(a,C),X=r.add(X,C),l=r.mul(_,X),G=r.add(G,l),l=r.mul(oe,X),V=r.mul(W,V),V=r.sub(V,l),l=r.mul(W,_),p=r.mul(oe,p),p=r.add(p,l),new y(V,G,p)}subtract(v){return this.add(v.negate())}is0(){return this.equals(y.ZERO)}multiply(v){const{endo:m}=n;if(!s.isValidNot0(v))throw new Error("invalid scalar: out of range");let A,z;const K=j=>k.cached(this,j,P=>$e(y,P));if(m){const{k1neg:j,k1:P,k2neg:V,k2:G}=Z(v),{p,f:a}=K(P),{p:u,f:l}=K(G);z=a.add(l),A=Q(m.beta,p,u,j,V)}else{const{p:j,f:P}=K(v);A=j,z=P}return $e(y,[A,z])[0]}multiplyUnsafe(v){const{endo:m}=n,A=this;if(!s.isValid(v))throw new Error("invalid scalar: out of range");if(v===Fe||A.is0())return y.ZERO;if(v===st)return A;if(k.hasCache(this))return this.multiply(v);if(m){const{k1neg:z,k1:K,k2neg:j,k2:P}=Z(v),{p1:V,p2:G}=_o(y,A,K,P);return Q(m.beta,V,G,z,j)}else return k.unsafe(A,v)}multiplyAndAddUnsafe(v,m,A){const z=this.multiplyUnsafe(m).add(v.multiplyUnsafe(A));return z.is0()?void 0:z}toAffine(v){return H(this,v)}isTorsionFree(){const{isTorsionFree:v}=n;return i===st?!0:v?v(y,this):k.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:v}=n;return i===st?this:v?v(y,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(v=!0){return Ye(v,"isCompressed"),this.assertValidity(),E(y,this,v)}toHex(v=!0){return Ze(this.toBytes(v))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(v=!0){return this.toBytes(v)}_setWindowSize(v){this.precompute(v)}static normalizeZ(v){return $e(y,v)}static msm(v,m){return Dr(y,s,v,m)}static fromPrivateKey(v){return y.BASE.multiply(et(s,v))}}y.BASE=new y(o.Gx,o.Gy,r.ONE),y.ZERO=new y(r.ZERO,r.ONE,r.ZERO),y.Fp=r,y.Fn=s;const w=s.BITS,k=new Fr(y,n.endo?Math.ceil(w/2):w);return y.BASE.precompute(8),y}function Gr(e){return Uint8Array.of(e?2:3)}function Hr(e,n){return{secretKey:n.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function Di(e,n={}){const{Fn:t}=e,r=n.randomBytes||vn,s=Object.assign(Hr(e.Fp,t),{seed:Cr(t.ORDER)});function o(E){try{return!!et(t,E)}catch{return!1}}function i(E,B){const{publicKey:U,publicKeyUncompressed:O}=s;try{const T=E.length;return B===!0&&T!==U||B===!1&&T!==O?!1:!!e.fromBytes(E)}catch{return!1}}function f(E=r(s.seed)){return Io(Ae(E,s.seed,"seed"),t.ORDER)}function c(E,B=!0){return e.BASE.multiply(et(t,E)).toBytes(B)}function h(E){const B=f(E);return{secretKey:B,publicKey:c(B)}}function b(E){if(typeof E=="bigint")return!1;if(E instanceof e)return!0;const{secretKey:B,publicKey:U,publicKeyUncompressed:O}=s;if(t.allowedLengths||B===U)return;const T=ce("key",E).length;return T===U||T===O}function R(E,B,U=!0){if(b(E)===!0)throw new Error("first arg must be private key");if(b(B)===!1)throw new Error("second arg must be public key");const O=et(t,E);return e.fromHex(B).multiply(O).toBytes(U)}return Object.freeze({getPublicKey:c,getSharedSecret:R,keygen:h,Point:e,utils:{isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:f,isValidPrivateKey:o,randomPrivateKey:f,normPrivateKeyToScalar:E=>et(t,E),precompute(E=8,B=e.BASE){return B.precompute(E,!1)}},lengths:s})}function Ki(e,n,t={}){ks(n),yt(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=t.randomBytes||vn,s=t.hmac||((m,...A)=>Ds(n,m,Oe(...A))),{Fp:o,Fn:i}=e,{ORDER:f,BITS:c}=i,{keygen:h,getPublicKey:b,getSharedSecret:R,utils:g,lengths:E}=Di(e,t),B={prehash:!1,lowS:typeof t.lowS=="boolean"?t.lowS:!1,format:void 0,extraEntropy:!1},U="compact";function O(m){const A=f>>st;return m>A}function T(m,A){if(!i.isValidNot0(A))throw new Error(`invalid signature ${m}: out of range 1..Point.Fn.ORDER`);return A}function F(m,A){yn(A);const z=E.signature,K=A==="compact"?z:A==="recovered"?z+1:void 0;return Ae(m,K,`${A} signature`)}class L{constructor(A,z,K){this.r=T("r",A),this.s=T("s",z),K!=null&&(this.recovery=K),Object.freeze(this)}static fromBytes(A,z=U){F(A,z);let K;if(z==="der"){const{r:G,s:p}=Ce.toSig(Ae(A));return new L(G,p)}z==="recovered"&&(K=A[0],z="compact",A=A.subarray(1));const j=i.BYTES,P=A.subarray(0,j),V=A.subarray(j,j*2);return new L(i.fromBytes(P),i.fromBytes(V),K)}static fromHex(A,z){return this.fromBytes(Bt(A),z)}addRecoveryBit(A){return new L(this.r,this.s,A)}recoverPublicKey(A){const z=o.ORDER,{r:K,s:j,recovery:P}=this;if(P==null||![0,1,2,3].includes(P))throw new Error("recovery id invalid");if(f*Yr<z&&P>1)throw new Error("recovery id is ambiguous for h>1 curve");const G=P===2||P===3?K+f:K;if(!o.isValid(G))throw new Error("recovery id 2 or 3 invalid");const p=o.toBytes(G),a=e.fromBytes(Oe(Gr((P&1)===0),p)),u=i.inv(G),l=Z(ce("msgHash",A)),_=i.create(-l*u),C=i.create(j*u),W=e.BASE.multiplyUnsafe(_).add(a.multiplyUnsafe(C));if(W.is0())throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return O(this.s)}toBytes(A=U){if(yn(A),A==="der")return Bt(Ce.hexFromSig(this));const z=i.toBytes(this.r),K=i.toBytes(this.s);if(A==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return Oe(Uint8Array.of(this.recovery),z,K)}return Oe(z,K)}toHex(A){return Ze(this.toBytes(A))}assertValidity(){}static fromCompact(A){return L.fromBytes(ce("sig",A),"compact")}static fromDER(A){return L.fromBytes(ce("sig",A),"der")}normalizeS(){return this.hasHighS()?new L(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Ze(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Ze(this.toBytes("compact"))}}const $=t.bits2int||function(A){if(A.length>8192)throw new Error("input is too large");const z=qt(A),K=A.length*8-c;return K>0?z>>BigInt(K):z},Z=t.bits2int_modN||function(A){return i.create($(A))},H=pt(c);function te(m){return pn("num < 2^"+c,m,Fe,H),i.toBytes(m)}function Q(m,A){return Ae(m,void 0,"message"),A?Ae(n(m),void 0,"prehashed message"):m}function y(m,A,z){if(["recovered","canonical"].some(_=>_ in z))throw new Error("sign() legacy options not supported");const{lowS:K,prehash:j,extraEntropy:P}=dn(z,B);m=Q(m,j);const V=Z(m),G=et(i,A),p=[te(G),te(V)];if(P!=null&&P!==!1){const _=P===!0?r(E.secretKey):P;p.push(ce("extraEntropy",_))}const a=Oe(...p),u=V;function l(_){const C=$(_);if(!i.isValidNot0(C))return;const W=i.inv(C),X=e.BASE.multiply(C).toAffine(),oe=i.create(X.x);if(oe===Fe)return;const Pe=i.create(W*i.create(u+oe*G));if(Pe===Fe)return;let Fn=(X.x===oe?0:2)|Number(X.y&st),Dn=Pe;return K&&O(Pe)&&(Dn=i.neg(Pe),Fn^=1),new L(oe,Dn,Fn)}return{seed:a,k2sig:l}}function w(m,A,z={}){m=ce("message",m);const{seed:K,k2sig:j}=y(m,A,z);return go(n.outputLen,i.BYTES,s)(K,j)}function k(m){let A;const z=typeof m=="string"||Ft(m),K=!z&&m!==null&&typeof m=="object"&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!z&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(K)A=new L(m.r,m.s);else if(z){try{A=L.fromBytes(ce("sig",m),"der")}catch(j){if(!(j instanceof Ce.Err))throw j}if(!A)try{A=L.fromBytes(ce("sig",m),"compact")}catch{return!1}}return A||!1}function I(m,A,z,K={}){const{lowS:j,prehash:P,format:V}=dn(K,B);if(z=ce("publicKey",z),A=Q(ce("message",A),P),"strict"in K)throw new Error("options.strict was renamed to lowS");const G=V===void 0?k(m):L.fromBytes(ce("sig",m),V);if(G===!1)return!1;try{const p=e.fromBytes(z);if(j&&G.hasHighS())return!1;const{r:a,s:u}=G,l=Z(A),_=i.inv(u),C=i.create(l*_),W=i.create(a*_),X=e.BASE.multiplyUnsafe(C).add(p.multiplyUnsafe(W));return X.is0()?!1:i.create(X.x)===a}catch{return!1}}function v(m,A,z={}){const{prehash:K}=dn(z,B);return A=Q(A,K),L.fromBytes(m,"recovered").recoverPublicKey(A).toBytes()}return Object.freeze({keygen:h,getPublicKey:b,getSharedSecret:R,utils:g,lengths:E,Point:e,sign:w,verify:I,recoverPublicKey:v,Signature:L,hash:n})}function qi(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp;let r=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const s=Ge(n.n,{BITS:e.nBitLength,allowedLengths:r,modFromBytes:e.wrapPrivateKey}),o={Fp:t,Fn:s,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:o}}function Mi(e){const{CURVE:n,curveOpts:t}=qi(e),r={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,hash:e.hash,ecdsaOpts:r}}function Pi(e,n){const t=n.Point;return Object.assign({},n,{ProjectivePoint:t,CURVE:Object.assign({},e,Ur(t.Fn.ORDER,t.Fn.BITS))})}function Vi(e){const{CURVE:n,curveOpts:t,hash:r,ecdsaOpts:s}=Mi(e),o=Fi(n,t),i=Ki(o,r,s);return Pi(e,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ji(e,n){const t=r=>Vi({...e,hash:r});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const On={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},$i={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},cr=BigInt(2);function Zi(e){const n=On.p,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),f=BigInt(44),c=BigInt(88),h=e*e*e%n,b=h*h*e%n,R=ae(b,t,n)*b%n,g=ae(R,t,n)*b%n,E=ae(g,cr,n)*h%n,B=ae(E,s,n)*E%n,U=ae(B,o,n)*B%n,O=ae(U,f,n)*U%n,T=ae(O,c,n)*O%n,F=ae(T,f,n)*U%n,L=ae(F,t,n)*b%n,$=ae(L,i,n)*B%n,Z=ae($,r,n)*h%n,H=ae(Z,cr,n);if(!gn.eql(gn.sqr(H),e))throw new Error("Cannot find square root");return H}const gn=Ge(On.p,{sqrt:Zi}),Yi=ji({...On,Fp:gn,lowS:!0,endo:$i},Ks);gt.utils.randomPrivateKey;gt.getPublicKey;function ur(e){try{return gt.ExtendedPoint.fromHex(e),!0}catch{return!1}}const Gi=(e,n)=>gt.sign(e,n.slice(0,32));gt.verify;const Wr=e=>ne.isBuffer(e)?e:e instanceof Uint8Array?ne.from(e.buffer,e.byteOffset,e.byteLength):ne.from(e);class Hi{constructor(n){Object.assign(this,n)}encode(){return ne.from(an.serialize(St,this))}static decode(n){return an.deserialize(St,this,n)}static decodeUnchecked(n){return an.deserializeUnchecked(St,this,n)}}const St=new Map;var Xr;const Wi=32,Me=32;function Xi(e){return e._bn!==void 0}let fr=1;class J extends Hi{constructor(n){if(super({}),this._bn=void 0,Xi(n))this._bn=n._bn;else{if(typeof n=="string"){const t=_e.decode(n);if(t.length!=Me)throw new Error("Invalid public key input");this._bn=new Mn(t)}else this._bn=new Mn(n);if(this._bn.byteLength()>Me)throw new Error("Invalid public key input")}}static unique(){const n=new J(fr);return fr+=1,new J(n.toBuffer())}equals(n){return this._bn.eq(n._bn)}toBase58(){return _e.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const n=this.toBuffer();return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}toBuffer(){const n=this._bn.toArrayLike(ne);if(n.length===Me)return n;const t=ne.alloc(32);return n.copy(t,32-n.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(n,t,r){const s=ne.concat([n.toBuffer(),ne.from(t),r.toBuffer()]),o=qn(s);return new J(o)}static createProgramAddressSync(n,t){let r=ne.alloc(0);n.forEach(function(o){if(o.length>Wi)throw new TypeError("Max seed length exceeded");r=ne.concat([r,Wr(o)])}),r=ne.concat([r,t.toBuffer(),ne.from("ProgramDerivedAddress")]);const s=qn(r);if(ur(s))throw new Error("Invalid seeds, address must fall off the curve");return new J(s)}static async createProgramAddress(n,t){return this.createProgramAddressSync(n,t)}static findProgramAddressSync(n,t){let r=255,s;for(;r!=0;){try{const o=n.concat(ne.from([r]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(n,t){return this.findProgramAddressSync(n,t)}static isOnCurve(n){const t=new J(n);return ur(t.toBytes())}}Xr=J;J.default=new Xr("11111111111111111111111111111111");St.set(J,{kind:"struct",fields:[["_bn","u256"]]});new J("BPFLoader1111111111111111111111111111111111");const At=1232,Tn=127,wn=64;class Lt{constructor(n,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=n,this.accountKeysFromLookups=t}keySegments(){const n=[this.staticAccountKeys];return this.accountKeysFromLookups&&(n.push(this.accountKeysFromLookups.writable),n.push(this.accountKeysFromLookups.readonly)),n}get(n){for(const t of this.keySegments()){if(n<t.length)return t[n];n-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(n){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return n.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const ee=(e="publicKey")=>d.blob(32,e),Ji=(e="signature")=>d.blob(64,e),tt=(e="string")=>{const n=d.struct([d.u32("length"),d.u32("lengthPadding"),d.blob(d.offset(d.u32(),-8),"chars")],e),t=n.decode.bind(n),r=n.encode.bind(n),s=n;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,f)=>{const c={chars:ne.from(o,"utf8")};return r(c,i,f)},s.alloc=o=>d.u32().span+d.u32().span+ne.from(o,"utf8").length,s},Qi=(e="authorized")=>d.struct([ee("staker"),ee("withdrawer")],e),ea=(e="lockup")=>d.struct([d.ns64("unixTimestamp"),d.ns64("epoch"),ee("custodian")],e),ta=(e="voteInit")=>d.struct([ee("nodePubkey"),ee("authorizedVoter"),ee("authorizedWithdrawer"),d.u8("commission")],e),na=(e="voteAuthorizeWithSeedArgs")=>d.struct([d.u32("voteAuthorizationType"),ee("currentAuthorityDerivedKeyOwnerPubkey"),tt("currentAuthorityDerivedKeySeed"),ee("newAuthorized")],e);function Ee(e){let n=0,t=0;for(;;){let r=e.shift();if(n|=(r&127)<<t*7,t+=1,(r&128)===0)break}return n}function ve(e,n){let t=n;for(;;){let r=t&127;if(t>>=7,t==0){e.push(r);break}else r|=128,e.push(r)}}function Te(e,n){if(!e)throw new Error(n||"Assertion failed")}class Pt{constructor(n,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=n,this.keyMetaMap=t}static compile(n,t){const r=new Map,s=i=>{const f=i.toBase58();let c=r.get(f);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(f,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of n){s(i.programId).isInvoked=!0;for(const f of i.keys){const c=s(f.pubkey);c.isSigner||(c.isSigner=f.isSigner),c.isWritable||(c.isWritable=f.isWritable)}}return new Pt(t,r)}getMessageComponents(){const n=[...this.keyMetaMap.entries()];Te(n.length<=256,"Max static account keys length exceeded");const t=n.filter(([,c])=>c.isSigner&&c.isWritable),r=n.filter(([,c])=>c.isSigner&&!c.isWritable),s=n.filter(([,c])=>!c.isSigner&&c.isWritable),o=n.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{Te(t.length>0,"Expected at least one writable signer key");const[c]=t[0];Te(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const f=[...t.map(([c])=>new J(c)),...r.map(([c])=>new J(c)),...s.map(([c])=>new J(c)),...o.map(([c])=>new J(c))];return[i,f]}extractTableLookup(n){const[t,r]=this.drainKeysFoundInLookupTable(n.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(n.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:n.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(n,t){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const f=new J(o),c=n.findIndex(h=>h.equals(f));c>=0&&(Te(c<256,"Max lookup table index exceeded"),r.push(c),s.push(f),this.keyMetaMap.delete(o))}return[r,s]}}const Jr="Reached end of buffer unexpectedly";function ze(e){if(e.length===0)throw new Error(Jr);return e.shift()}function xe(e,...n){const[t]=n;if(n.length===2?t+(n[1]??0)>e.length:t>=e.length)throw new Error(Jr);return e.splice(...n)}class Ct{constructor(n){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=n.header,this.accountKeys=n.accountKeys.map(t=>new J(t)),this.recentBlockhash=n.recentBlockhash,this.instructions=n.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(n=>({programIdIndex:n.programIdIndex,accountKeyIndexes:n.accounts,data:_e.decode(n.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Lt(this.staticAccountKeys)}static compile(n){const t=Pt.compile(n.instructions,n.payerKey),[r,s]=t.getMessageComponents(),i=new Lt(s).compileInstructions(n.instructions).map(f=>({programIdIndex:f.programIdIndex,accounts:f.accountKeyIndexes,data:_e.encode(f.data)}));return new Ct({header:r,accountKeys:s,recentBlockhash:n.recentBlockhash,instructions:i})}isAccountSigner(n){return n<this.header.numRequiredSignatures}isAccountWritable(n){const t=this.header.numRequiredSignatures;if(n>=this.header.numRequiredSignatures){const r=n-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return n<r}}isProgramId(n){return this.indexToProgramIds.has(n)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((n,t)=>!this.isProgramId(t))}serialize(){const n=this.accountKeys.length;let t=[];ve(t,n);const r=this.instructions.map(R=>{const{accounts:g,programIdIndex:E}=R,B=Array.from(_e.decode(R.data));let U=[];ve(U,g.length);let O=[];return ve(O,B.length),{programIdIndex:E,keyIndicesCount:ne.from(U),keyIndices:g,dataLength:ne.from(O),data:B}});let s=[];ve(s,r.length);let o=ne.alloc(At);ne.from(s).copy(o);let i=s.length;r.forEach(R=>{const E=d.struct([d.u8("programIdIndex"),d.blob(R.keyIndicesCount.length,"keyIndicesCount"),d.seq(d.u8("keyIndex"),R.keyIndices.length,"keyIndices"),d.blob(R.dataLength.length,"dataLength"),d.seq(d.u8("userdatum"),R.data.length,"data")]).encode(R,o,i);i+=E}),o=o.slice(0,i);const f=d.struct([d.blob(1,"numRequiredSignatures"),d.blob(1,"numReadonlySignedAccounts"),d.blob(1,"numReadonlyUnsignedAccounts"),d.blob(t.length,"keyCount"),d.seq(ee("key"),n,"keys"),ee("recentBlockhash")]),c={numRequiredSignatures:ne.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:ne.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:ne.from([this.header.numReadonlyUnsignedAccounts]),keyCount:ne.from(t),keys:this.accountKeys.map(R=>Wr(R.toBytes())),recentBlockhash:_e.decode(this.recentBlockhash)};let h=ne.alloc(2048);const b=f.encode(c,h);return o.copy(h,b),h.slice(0,b+o.length)}static from(n){let t=[...n];const r=ze(t);if(r!==(r&Tn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=ze(t),o=ze(t),i=Ee(t);let f=[];for(let g=0;g<i;g++){const E=xe(t,0,Me);f.push(new J(ne.from(E)))}const c=xe(t,0,Me),h=Ee(t);let b=[];for(let g=0;g<h;g++){const E=ze(t),B=Ee(t),U=xe(t,0,B),O=Ee(t),T=xe(t,0,O),F=_e.encode(ne.from(T));b.push({programIdIndex:E,accounts:U,data:F})}const R={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:_e.encode(ne.from(c)),accountKeys:f,instructions:b};return new Ct(R)}}class Nt{constructor(n){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=n.header,this.staticAccountKeys=n.staticAccountKeys,this.recentBlockhash=n.recentBlockhash,this.compiledInstructions=n.compiledInstructions,this.addressTableLookups=n.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let n=0;for(const t of this.addressTableLookups)n+=t.readonlyIndexes.length+t.writableIndexes.length;return n}getAccountKeys(n){let t;if(n&&"accountKeysFromLookups"in n&&n.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=n.accountKeysFromLookups.writable.length+n.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=n.accountKeysFromLookups}else if(n&&"addressLookupTableAccounts"in n&&n.addressLookupTableAccounts)t=this.resolveAddressTableLookups(n.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Lt(this.staticAccountKeys,t)}isAccountSigner(n){return n<this.header.numRequiredSignatures}isAccountWritable(n){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(n>=r){const s=n-r,o=this.addressTableLookups.reduce((i,f)=>i+f.writableIndexes.length,0);return s<o}else if(n>=this.header.numRequiredSignatures){const s=n-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return n<s}}resolveAddressTableLookups(n){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=n.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(n){const t=Pt.compile(n.instructions,n.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=n.addressLookupTableAccounts||[];for(const b of o){const R=t.extractTableLookup(b);if(R!==void 0){const[g,{writable:E,readonly:B}]=R;r.push(g),s.writable.push(...E),s.readonly.push(...B)}}const[i,f]=t.getMessageComponents(),h=new Lt(f,s).compileInstructions(n.instructions);return new Nt({header:i,staticAccountKeys:f,recentBlockhash:n.recentBlockhash,compiledInstructions:h,addressTableLookups:r})}serialize(){const n=Array();ve(n,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();ve(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();ve(o,this.addressTableLookups.length);const i=d.struct([d.u8("prefix"),d.struct([d.u8("numRequiredSignatures"),d.u8("numReadonlySignedAccounts"),d.u8("numReadonlyUnsignedAccounts")],"header"),d.blob(n.length,"staticAccountKeysLength"),d.seq(ee(),this.staticAccountKeys.length,"staticAccountKeys"),ee("recentBlockhash"),d.blob(r.length,"instructionsLength"),d.blob(t.length,"serializedInstructions"),d.blob(o.length,"addressTableLookupsLength"),d.blob(s.length,"serializedAddressTableLookups")]),f=new Uint8Array(At),h=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(n),staticAccountKeys:this.staticAccountKeys.map(b=>b.toBytes()),recentBlockhash:_e.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},f);return f.slice(0,h)}serializeInstructions(){let n=0;const t=new Uint8Array(At);for(const r of this.compiledInstructions){const s=Array();ve(s,r.accountKeyIndexes.length);const o=Array();ve(o,r.data.length);const i=d.struct([d.u8("programIdIndex"),d.blob(s.length,"encodedAccountKeyIndexesLength"),d.seq(d.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),d.blob(o.length,"encodedDataLength"),d.blob(r.data.length,"data")]);n+=i.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,n)}return t.slice(0,n)}serializeAddressTableLookups(){let n=0;const t=new Uint8Array(At);for(const r of this.addressTableLookups){const s=Array();ve(s,r.writableIndexes.length);const o=Array();ve(o,r.readonlyIndexes.length);const i=d.struct([ee("accountKey"),d.blob(s.length,"encodedWritableIndexesLength"),d.seq(d.u8(),r.writableIndexes.length,"writableIndexes"),d.blob(o.length,"encodedReadonlyIndexesLength"),d.seq(d.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);n+=i.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,n)}return t.slice(0,n)}static deserialize(n){let t=[...n];const r=ze(t),s=r&Tn;Te(r!==s,"Expected versioned message but received legacy message");const o=s;Te(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:ze(t),numReadonlySignedAccounts:ze(t),numReadonlyUnsignedAccounts:ze(t)},f=[],c=Ee(t);for(let B=0;B<c;B++)f.push(new J(xe(t,0,Me)));const h=_e.encode(xe(t,0,Me)),b=Ee(t),R=[];for(let B=0;B<b;B++){const U=ze(t),O=Ee(t),T=xe(t,0,O),F=Ee(t),L=new Uint8Array(xe(t,0,F));R.push({programIdIndex:U,accountKeyIndexes:T,data:L})}const g=Ee(t),E=[];for(let B=0;B<g;B++){const U=new J(xe(t,0,Me)),O=Ee(t),T=xe(t,0,O),F=Ee(t),L=xe(t,0,F);E.push({accountKey:U,writableIndexes:T,readonlyIndexes:L})}return new Nt({header:i,staticAccountKeys:f,recentBlockhash:h,compiledInstructions:R,addressTableLookups:E})}}const Qr={deserializeMessageVersion(e){const n=e[0],t=n&Tn;return t===n?"legacy":t},deserialize:e=>{const n=Qr.deserializeMessageVersion(e);if(n==="legacy")return Ct.from(e);if(n===0)return Nt.deserialize(e);throw new Error(`Transaction message version ${n} deserialization is not supported`)}};ne.alloc(wn).fill(0);class Un{get version(){return this.message.version}constructor(n,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)Te(t.length===n.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let s=0;s<n.header.numRequiredSignatures;s++)r.push(new Uint8Array(wn));this.signatures=r}this.message=n}serialize(){const n=this.message.serialize(),t=Array();ve(t,this.signatures.length);const r=d.struct([d.blob(t.length,"encodedSignaturesLength"),d.seq(Ji(),this.signatures.length,"signatures"),d.blob(n.length,"serializedMessage")]),s=new Uint8Array(2048),o=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:n},s);return s.slice(0,o)}static deserialize(n){let t=[...n];const r=[],s=Ee(t);for(let i=0;i<s;i++)r.push(new Uint8Array(xe(t,0,wn)));const o=Qr.deserialize(new Uint8Array(t));return new Un(o,r)}sign(n){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of n){const o=r.findIndex(i=>i.equals(s.publicKey));Te(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=Gi(t,s.secretKey)}}addSignature(n,t){Te(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(n));Te(s>=0,`Can not add signature; \`${n.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}new J("SysvarC1ock11111111111111111111111111111111");new J("SysvarEpochSchedu1e111111111111111111111111");new J("Sysvar1nstructions1111111111111111111111111");new J("SysvarRecentB1ockHashes11111111111111111111");new J("SysvarRent111111111111111111111111111111111");new J("SysvarRewards111111111111111111111111111111");new J("SysvarS1otHashes111111111111111111111111111");new J("SysvarS1otHistory11111111111111111111111111");new J("SysvarStakeHistory1111111111111111111111111");const ra=d.nu64("lamportsPerSignature"),sa=d.struct([d.u32("version"),d.u32("state"),ee("authorizedPubkey"),ee("nonce"),d.struct([ra],"feeCalculator")]);sa.span;function at(e){const n=d.blob(8,e),t=n.decode.bind(n),r=n.encode.bind(n),s=n,o=xi();return s.decode=(i,f)=>{const c=t(i,f);return o.decode(c)},s.encode=(i,f,c)=>{const h=o.encode(i);return r(h,f,c)},s}Object.freeze({Create:{index:0,layout:d.struct([d.u32("instruction"),d.ns64("lamports"),d.ns64("space"),ee("programId")])},Assign:{index:1,layout:d.struct([d.u32("instruction"),ee("programId")])},Transfer:{index:2,layout:d.struct([d.u32("instruction"),at("lamports")])},CreateWithSeed:{index:3,layout:d.struct([d.u32("instruction"),ee("base"),tt("seed"),d.ns64("lamports"),d.ns64("space"),ee("programId")])},AdvanceNonceAccount:{index:4,layout:d.struct([d.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:d.struct([d.u32("instruction"),d.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:d.struct([d.u32("instruction"),ee("authorized")])},AuthorizeNonceAccount:{index:7,layout:d.struct([d.u32("instruction"),ee("authorized")])},Allocate:{index:8,layout:d.struct([d.u32("instruction"),d.ns64("space")])},AllocateWithSeed:{index:9,layout:d.struct([d.u32("instruction"),ee("base"),tt("seed"),d.ns64("space"),ee("programId")])},AssignWithSeed:{index:10,layout:d.struct([d.u32("instruction"),ee("base"),tt("seed"),ee("programId")])},TransferWithSeed:{index:11,layout:d.struct([d.u32("instruction"),at("lamports"),tt("seed"),ee("programId")])},UpgradeNonceAccount:{index:12,layout:d.struct([d.u32("instruction")])}});new J("11111111111111111111111111111111");new J("BPFLoader2111111111111111111111111111111111");d.struct([d.u32("typeIndex"),at("deactivationSlot"),d.nu64("lastExtendedSlot"),d.u8("lastExtendedStartIndex"),d.u8(),d.seq(ee(),d.offset(d.u8(),-1),"authority")]);const ue=bt(kn(J),D(),e=>new J(e)),es=_n([D(),ie("base64")]),Ln=bt(kn(ne),es,e=>ne.from(e[0],"base64"));function ts(e){return me([N({jsonrpc:ie("2.0"),id:D(),result:e}),N({jsonrpc:ie("2.0"),id:D(),error:N({code:ct(),message:D(),data:Y(_i())})})])}const oa=ts(ct());function se(e){return bt(ts(e),oa,n=>"error"in n?n:{...n,result:ht(n.result,e)})}function Ie(e){return se(N({context:N({slot:x()}),value:e}))}function Vt(e){return N({context:N({slot:x()}),value:e})}const ia=N({foundation:x(),foundationTerm:x(),initial:x(),taper:x(),terminal:x()});se(q(M(N({epoch:x(),effectiveSlot:x(),amount:x(),postBalance:x(),commission:Y(M(x()))}))));const aa=q(N({slot:x(),prioritizationFee:x()})),ca=N({total:x(),validator:x(),foundation:x(),epoch:x()}),ua=N({epoch:x(),slotIndex:x(),slotsInEpoch:x(),absoluteSlot:x(),blockHeight:Y(x()),transactionCount:Y(x())}),fa=N({slotsPerEpoch:x(),leaderScheduleSlotOffset:x(),warmup:Ue(),firstNormalEpoch:x(),firstNormalSlot:x()}),da=$r(D(),q(x())),We=M(me([N({}),D()])),la=N({err:We}),ha=ie("receivedSignature");N({"solana-core":D(),"feature-set":Y(x())});const pa=N({program:D(),programId:ue,parsed:ct()}),ya=N({programId:ue,accounts:q(ue),data:D()});Ie(N({err:M(me([N({}),D()])),logs:M(q(D())),accounts:Y(M(q(M(N({executable:Ue(),owner:D(),lamports:x(),data:q(D()),rentEpoch:Y(x())}))))),unitsConsumed:Y(x()),returnData:Y(M(N({programId:D(),data:_n([D(),ie("base64")])}))),innerInstructions:Y(M(q(N({index:x(),instructions:q(me([pa,ya]))}))))}));Ie(N({byIdentity:$r(D(),q(x())),range:N({firstSlot:x(),lastSlot:x()})}));se(ia);se(ca);se(aa);se(ua);se(fa);se(da);se(x());Ie(N({total:x(),circulating:x(),nonCirculating:x(),nonCirculatingAccounts:q(ue)}));const ga=N({amount:D(),uiAmount:M(x()),decimals:x(),uiAmountString:Y(D())});Ie(q(N({address:ue,amount:D(),uiAmount:M(x()),decimals:x(),uiAmountString:Y(D())})));Ie(q(N({pubkey:ue,account:N({executable:Ue(),owner:ue,lamports:x(),data:Ln,rentEpoch:x()})})));const mn=N({program:D(),parsed:ct(),space:x()});Ie(q(N({pubkey:ue,account:N({executable:Ue(),owner:ue,lamports:x(),data:mn,rentEpoch:x()})})));Ie(q(N({lamports:x(),address:ue})));const Cn=N({executable:Ue(),owner:ue,lamports:x(),data:Ln,rentEpoch:x()});N({pubkey:ue,account:Cn});const wa=bt(me([kn(ne),mn]),me([es,mn]),e=>Array.isArray(e)?ht(e,Ln):e),ma=N({executable:Ue(),owner:ue,lamports:x(),data:wa,rentEpoch:x()});N({pubkey:ue,account:ma});N({state:me([ie("active"),ie("inactive"),ie("activating"),ie("deactivating")]),active:x(),inactive:x()});se(q(N({signature:D(),slot:x(),err:We,memo:M(D()),blockTime:Y(M(x()))})));se(q(N({signature:D(),slot:x(),err:We,memo:M(D()),blockTime:Y(M(x()))})));N({subscription:x(),result:Vt(Cn)});const ba=N({pubkey:ue,account:Cn});N({subscription:x(),result:Vt(ba)});const Ea=N({parent:x(),slot:x(),root:x()});N({subscription:x(),result:Ea});const va=me([N({type:me([ie("firstShredReceived"),ie("completed"),ie("optimisticConfirmation"),ie("root")]),slot:x(),timestamp:x()}),N({type:ie("createdBank"),parent:x(),slot:x(),timestamp:x()}),N({type:ie("frozen"),slot:x(),timestamp:x(),stats:N({numTransactionEntries:x(),numSuccessfulTransactions:x(),numFailedTransactions:x(),maxTransactionsPerEntry:x()})}),N({type:ie("dead"),slot:x(),timestamp:x(),err:D()})]);N({subscription:x(),result:va});N({subscription:x(),result:Vt(me([la,ha]))});N({subscription:x(),result:x()});N({pubkey:D(),gossip:M(D()),tpu:M(D()),rpc:M(D()),version:M(D())});const dr=N({votePubkey:D(),nodePubkey:D(),activatedStake:x(),epochVoteAccount:Ue(),epochCredits:q(_n([x(),x(),x()])),commission:x(),lastVote:x(),rootSlot:M(x())});se(N({current:q(dr),delinquent:q(dr)}));const xa=me([ie("processed"),ie("confirmed"),ie("finalized")]),Sa=N({slot:x(),confirmations:M(x()),err:We,confirmationStatus:Y(xa)});Ie(q(M(Sa)));se(x());const ns=N({accountKey:ue,writableIndexes:q(x()),readonlyIndexes:q(x())}),Nn=N({signatures:q(D()),message:N({accountKeys:q(D()),header:N({numRequiredSignatures:x(),numReadonlySignedAccounts:x(),numReadonlyUnsignedAccounts:x()}),instructions:q(N({accounts:q(x()),data:D(),programIdIndex:x()})),recentBlockhash:D(),addressTableLookups:Y(q(ns))})}),rs=N({pubkey:ue,signer:Ue(),writable:Ue(),source:Y(me([ie("transaction"),ie("lookupTable")]))}),ss=N({accountKeys:q(rs),signatures:q(D())}),os=N({parsed:ct(),program:D(),programId:ue}),is=N({accounts:q(ue),data:D(),programId:ue}),Aa=me([is,os]),Ba=me([N({parsed:ct(),program:D(),programId:D()}),N({accounts:q(D()),data:D(),programId:D()})]),as=bt(Aa,Ba,e=>"accounts"in e?ht(e,is):ht(e,os)),cs=N({signatures:q(D()),message:N({accountKeys:q(rs),instructions:q(as),recentBlockhash:D(),addressTableLookups:Y(M(q(ns)))})}),zt=N({accountIndex:x(),mint:D(),owner:Y(D()),programId:Y(D()),uiTokenAmount:ga}),us=N({writable:q(ue),readonly:q(ue)}),jt=N({err:We,fee:x(),innerInstructions:Y(M(q(N({index:x(),instructions:q(N({accounts:q(x()),data:D(),programIdIndex:x()}))})))),preBalances:q(x()),postBalances:q(x()),logMessages:Y(M(q(D()))),preTokenBalances:Y(M(q(zt))),postTokenBalances:Y(M(q(zt))),loadedAddresses:Y(us),computeUnitsConsumed:Y(x()),costUnits:Y(x())}),zn=N({err:We,fee:x(),innerInstructions:Y(M(q(N({index:x(),instructions:q(as)})))),preBalances:q(x()),postBalances:q(x()),logMessages:Y(M(q(D()))),preTokenBalances:Y(M(q(zt))),postTokenBalances:Y(M(q(zt))),loadedAddresses:Y(us),computeUnitsConsumed:Y(x()),costUnits:Y(x())}),ut=me([ie(0),ie("legacy")]),Xe=N({pubkey:D(),lamports:x(),postBalance:M(x()),rewardType:M(D()),commission:Y(M(x()))});se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),transactions:q(N({transaction:Nn,meta:M(jt),version:Y(ut)})),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),transactions:q(N({transaction:ss,meta:M(jt),version:Y(ut)})),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),transactions:q(N({transaction:cs,meta:M(zn),version:Y(ut)})),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),transactions:q(N({transaction:ss,meta:M(zn),version:Y(ut)})),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),rewards:Y(q(Xe)),blockTime:M(x()),blockHeight:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),transactions:q(N({transaction:Nn,meta:M(jt)})),rewards:Y(q(Xe)),blockTime:M(x())})));se(M(N({blockhash:D(),previousBlockhash:D(),parentSlot:x(),signatures:q(D()),blockTime:M(x())})));se(M(N({slot:x(),meta:M(jt),blockTime:Y(M(x())),transaction:Nn,version:Y(ut)})));se(M(N({slot:x(),transaction:cs,meta:M(zn),blockTime:Y(M(x())),version:Y(ut)})));Ie(N({blockhash:D(),lastValidBlockHeight:x()}));Ie(Ue());const Ia=N({slot:x(),numTransactions:x(),numSlots:x(),samplePeriodSecs:x()});se(q(Ia));Ie(M(N({feeCalculator:N({lamportsPerSignature:x()})})));se(D());se(D());const Ra=N({err:We,logs:q(D()),signature:D()});N({result:Vt(Ra),subscription:x()});Object.freeze({CreateLookupTable:{index:0,layout:d.struct([d.u32("instruction"),at("recentSlot"),d.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:d.struct([d.u32("instruction")])},ExtendLookupTable:{index:2,layout:d.struct([d.u32("instruction"),at(),d.seq(ee(),d.offset(d.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:d.struct([d.u32("instruction")])},CloseLookupTable:{index:4,layout:d.struct([d.u32("instruction")])}});new J("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:d.struct([d.u8("instruction"),d.u32("units"),d.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:d.struct([d.u8("instruction"),d.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:d.struct([d.u8("instruction"),d.u32("units")])},SetComputeUnitPrice:{index:3,layout:d.struct([d.u8("instruction"),at("microLamports")])}});new J("ComputeBudget111111111111111111111111111111");d.struct([d.u8("numSignatures"),d.u8("padding"),d.u16("signatureOffset"),d.u16("signatureInstructionIndex"),d.u16("publicKeyOffset"),d.u16("publicKeyInstructionIndex"),d.u16("messageDataOffset"),d.u16("messageDataSize"),d.u16("messageInstructionIndex")]);new J("Ed25519SigVerify111111111111111111111111111");Yi.utils.isValidPrivateKey;d.struct([d.u8("numSignatures"),d.u16("signatureOffset"),d.u8("signatureInstructionIndex"),d.u16("ethAddressOffset"),d.u8("ethAddressInstructionIndex"),d.u16("messageDataOffset"),d.u16("messageDataSize"),d.u8("messageInstructionIndex"),d.blob(20,"ethAddress"),d.blob(64,"signature"),d.u8("recoveryId")]);new J("KeccakSecp256k11111111111111111111111111111");var fs;new J("StakeConfig11111111111111111111111111111111");class ds{constructor(n,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=n,this.epoch=t,this.custodian=r}}fs=ds;ds.default=new fs(0,0,J.default);Object.freeze({Initialize:{index:0,layout:d.struct([d.u32("instruction"),Qi(),ea()])},Authorize:{index:1,layout:d.struct([d.u32("instruction"),ee("newAuthorized"),d.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:d.struct([d.u32("instruction")])},Split:{index:3,layout:d.struct([d.u32("instruction"),d.ns64("lamports")])},Withdraw:{index:4,layout:d.struct([d.u32("instruction"),d.ns64("lamports")])},Deactivate:{index:5,layout:d.struct([d.u32("instruction")])},Merge:{index:7,layout:d.struct([d.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:d.struct([d.u32("instruction"),ee("newAuthorized"),d.u32("stakeAuthorizationType"),tt("authoritySeed"),ee("authorityOwner")])}});new J("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:d.struct([d.u32("instruction"),ta()])},Authorize:{index:1,layout:d.struct([d.u32("instruction"),ee("newAuthorized"),d.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:d.struct([d.u32("instruction"),d.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:d.struct([d.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:d.struct([d.u32("instruction"),na()])}});new J("Vote111111111111111111111111111111111111111");new J("Va1idator1nfo111111111111111111111111111111");N({name:D(),website:Y(D()),details:Y(D()),iconUrl:Y(D()),keybaseUsername:Y(D())});new J("Vote111111111111111111111111111111111111111");d.struct([ee("nodePubkey"),ee("authorizedWithdrawer"),d.u8("commission"),d.nu64(),d.seq(d.struct([d.nu64("slot"),d.u32("confirmationCount")]),d.offset(d.u32(),-8),"votes"),d.u8("rootSlotValid"),d.nu64("rootSlot"),d.nu64(),d.seq(d.struct([d.nu64("epoch"),ee("authorizedVoter")]),d.offset(d.u32(),-8),"authorizedVoters"),d.struct([d.seq(d.struct([ee("authorizedPubkey"),d.nu64("epochOfLastAuthorizedSwitch"),d.nu64("targetEpoch")]),32,"buf"),d.nu64("idx"),d.u8("isEmpty")],"priorVoters"),d.nu64(),d.seq(d.struct([d.nu64("epoch"),d.nu64("credits"),d.nu64("prevCredits")]),d.offset(d.u32(),-8),"epochCredits"),d.struct([d.nu64("slot"),d.nu64("timestamp")],"lastTimestamp")]);class ka extends _s{constructor({config:n,state:t}){super({config:n,state:t})}async switchChain(n){throw Re.unsupportedOperation("Chain switching is not supported by this connector")}async setupProvider(n,t){const r=new Os,s=this.getChain(t),o=this.getProviderHandlers(n),i=qs(o);r.push(i);const f=Ms(s);r.push(f);const c=this.getInjectedProviderProxy(n);c&&r.push(c);const h=Ts(r);this.updateProviderEngineProxy(h),await this.lookupNetwork(n,t)}async lookupNetwork(n,t){return this.update({chainId:t}),t||""}getInjectedProviderProxy(n){}}const _a=e=>({requestAccounts:async()=>e.publicKey?[nt.encode(e.publicKey.toBytes())]:[],getPublicKey:async()=>e.publicKey?nt.encode(e.publicKey.toBytes()):"",getAccounts:async()=>e.publicKey?[nt.encode(e.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw Yt.methodNotSupported()},getSecretKey:async()=>{throw Yt.methodNotSupported()},signTransaction:async t=>await e.signTransaction(t.params.message),signMessage:async t=>await e.signMessage(t.params.data,t.params.from,t.params.display),signAllTransactions:async t=>{var r,s;if(!((r=t.params)!==null&&r!==void 0&&r.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw Yt.invalidParams("message");return await e.signAllTransactions(t.params.message)},signAndSendTransaction:async t=>await e.signAndSendTransaction(t.params.message)}),ls=e=>{switch(e.chainId){case"0x65":return"solana:mainnet";case"0x66":return"solana:testnet";case"0x67":return"solana:devnet";default:return null}};class Oa extends ka{getProviderHandlers(n){const t=ls(this.config.chain),r=()=>{const c=n==null?void 0:n.accounts[0];if(!c)throw Re.notConnectedError();return c};return _a({get publicKey(){return new J(r().publicKey)},signMessage:async c=>{const h=r(),b=new Uint8Array(fe.from(c,"utf-8")),R=await n.features[br].signMessage({account:h,message:b});return nt.encode(R[0].signature)},signTransaction:async c=>{const h=r(),b=await n.features[ln].signTransaction({account:h,transaction:new Uint8Array(fe.from(c,"base64")),chain:t});return nt.encode(Un.deserialize(b[0].signedTransaction).signatures[0])},signAllTransactions:async c=>{const h=r();return Promise.all(c.map(async b=>{const R=await n.features[ln].signTransaction({account:h,transaction:new Uint8Array(fe.from(b,"base64")),chain:t});return fe.from(R[0].signedTransaction).toString("base64")}))},signAndSendTransaction:async c=>{const h=r(),b=await n.features[mr].signAndSendTransaction({account:h,transaction:new Uint8Array(fe.from(c,"base64")),chain:t});return nt.encode(b[0].signature)}})}}class Ta extends oo{constructor(n){super(n),De(this,"name",void 0),De(this,"connectorNamespace",Ls.SOLANA),De(this,"currentChainNamespace",Cs.SOLANA),De(this,"type",Ns.EXTERNAL),De(this,"isInjected",!0),De(this,"status",Se.NOT_READY),De(this,"wallet",null),De(this,"injectedProvider",null),this.name=n.name,this.icon=n.wallet.icon,this.wallet=["gate","solflare"].includes(this.name)?Object.freeze(n.wallet):n.wallet}get provider(){return this.status!==Se.NOT_READY&&this.injectedProvider?this.injectedProvider:null}get isWalletConnected(){return!!(this.connected&&this.wallet.accounts.length>0)}async init(n){await super.init(n);const t=this.coreOptions.chains.find(r=>r.chainId===n.chainId);super.checkInitializationRequirements({chainConfig:t}),this.injectedProvider=new Oa({config:{chain:t,chains:this.coreOptions.chains}}),await this.injectedProvider.setupProvider(this.wallet,n.chainId),this.status=Se.READY,this.emit(ke.READY,this.name);try{if(zs.debug("initializing solana injected connector"),n.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:n.chainId,getIdentityToken:n.getIdentityToken})))throw this.rehydrated=!1,Re.connectionError("Failed to rehydrate.")}catch(r){this.emit(ke.REHYDRATION_ERROR,r)}}async connect({chainId:n,getIdentityToken:t}){try{super.checkConnectionRequirements();const r=this.coreOptions.chains.find(i=>i.chainId===n);if(!r)throw Re.connectionError("Chain config is not available");this.status=Se.CONNECTING,this.emit(ke.CONNECTING,{connector:this.name});const s=ls(r);if(!this.wallet.chains.find(i=>i===s))throw Re.connectionError(`Chain ${s} not supported. Supported chains are ${this.wallet.chains.join(", ")}`);if(this.isWalletConnected||await this.wallet.features[Er].connect(),this.wallet.accounts.length===0)throw Re.connectionError();this.status=Se.CONNECTED;let o;return this.emit(ke.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.provider,identityTokenInfo:o}),t&&(o=await this.getIdentityToken()),this.provider}catch(r){throw this.status=Se.READY,this.rehydrated||this.emit(ke.ERRORED,r),this.rehydrated=!1,r}}async disconnect(n={cleanup:!1}){await super.disconnectSession();try{var t;await((t=this.wallet.features[po])===null||t===void 0?void 0:t.disconnect()),n.cleanup?(this.status=Se.NOT_READY,this.injectedProvider=null):this.status=Se.READY,await super.disconnect()}catch(r){this.emit(ke.ERRORED,Re.disconnectionError(r==null?void 0:r.message))}}async getUserInfo(){if(!this.canAuthorize)throw Re.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(n,t=!1){var r;super.checkSwitchChainRequirements(n,t),await((r=this.injectedProvider)===null||r===void 0?void 0:r.switchChain(n))}async enableMFA(){throw new Error("Method not implemented.")}async manageMFA(){throw new Error("Method Not implemented")}}const qa=e=>({coreOptions:n})=>new Ta({name:Us(e.name),wallet:e,coreOptions:n}),Ma=e=>{const{chains:n,features:t}=e;return n.some(o=>o.startsWith("solana"))?!![Er,br,ln,mr].every(o=>Object.keys(t).includes(o)):void 0};export{Fa as createSolanaMipd,Ma as hasSolanaWalletStandardFeatures,qa as walletStandardConnector};
